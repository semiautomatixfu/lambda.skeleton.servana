/**
 * Manage API
 * AssetChain Manage api
 *
 * OpenAPI spec version: 0.1
 * Contact: api.admin@assetchain.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

let defaultBasePath = 'https://localhost:8081';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class Account {
    'accountName'?: string;
    'accountNumber'?: string;
    'accountType'?: string;
    'availableBalance'?: number;
    'balance'?: number;
    'bankName'?: string;
    'bsbs'?: Array<string>;
    'clusterCompleted'?: Date;
    'container'?: string;
    'created'?: Date;
    'displayName'?: string;
    'externalId'?: string;
    'externalStatus'?: string;
    'externalUpdated'?: Date;
    'id'?: string;
    'interestRate'?: number;
    'linkId'?: string;
    'memberId'?: string;
    'status'?: Account.StatusEnum;
    'statusUpdated'?: Date;
    'transactionStatus'?: Account.TransactionStatusEnum;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountName",
            "baseName": "accountName",
            "type": "string"
        },
        {
            "name": "accountNumber",
            "baseName": "accountNumber",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "accountType",
            "type": "string"
        },
        {
            "name": "availableBalance",
            "baseName": "availableBalance",
            "type": "number"
        },
        {
            "name": "balance",
            "baseName": "balance",
            "type": "number"
        },
        {
            "name": "bankName",
            "baseName": "bankName",
            "type": "string"
        },
        {
            "name": "bsbs",
            "baseName": "bsbs",
            "type": "Array<string>"
        },
        {
            "name": "clusterCompleted",
            "baseName": "clusterCompleted",
            "type": "Date"
        },
        {
            "name": "container",
            "baseName": "container",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "externalId",
            "baseName": "externalId",
            "type": "string"
        },
        {
            "name": "externalStatus",
            "baseName": "externalStatus",
            "type": "string"
        },
        {
            "name": "externalUpdated",
            "baseName": "externalUpdated",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "interestRate",
            "baseName": "interestRate",
            "type": "number"
        },
        {
            "name": "linkId",
            "baseName": "linkId",
            "type": "string"
        },
        {
            "name": "memberId",
            "baseName": "memberId",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Account.StatusEnum"
        },
        {
            "name": "statusUpdated",
            "baseName": "statusUpdated",
            "type": "Date"
        },
        {
            "name": "transactionStatus",
            "baseName": "transactionStatus",
            "type": "Account.TransactionStatusEnum"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Account.attributeTypeMap;
    }
}

export namespace Account {
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        DISABLED = <any> 'DISABLED'
    }
    export enum TransactionStatusEnum {
        NOTSTARTED = <any> 'NOT_STARTED',
        STARTED = <any> 'STARTED',
        DONE = <any> 'DONE',
        FAILED = <any> 'FAILED',
        UPDATING = <any> 'UPDATING'
    }
}
export class AccountBalanceResponse {
    'balances'?: { [key: string]: number; };
    'date'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "balances",
            "baseName": "balances",
            "type": "{ [key: string]: number; }"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccountBalanceResponse.attributeTypeMap;
    }
}

export class AccountCreateRequest {
    'accountName'?: string;
    'accountNumber'?: string;
    'accountType'?: string;
    'availableBalance'?: number;
    'balance'?: number;
    'bankName'?: string;
    'bsbs'?: Array<string>;
    'container'?: string;
    'displayName'?: string;
    'externalId'?: string;
    'externalStatus'?: string;
    'externalUpdated'?: Date;
    'interestRate'?: number;
    'linkId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountName",
            "baseName": "accountName",
            "type": "string"
        },
        {
            "name": "accountNumber",
            "baseName": "accountNumber",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "accountType",
            "type": "string"
        },
        {
            "name": "availableBalance",
            "baseName": "availableBalance",
            "type": "number"
        },
        {
            "name": "balance",
            "baseName": "balance",
            "type": "number"
        },
        {
            "name": "bankName",
            "baseName": "bankName",
            "type": "string"
        },
        {
            "name": "bsbs",
            "baseName": "bsbs",
            "type": "Array<string>"
        },
        {
            "name": "container",
            "baseName": "container",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "externalId",
            "baseName": "externalId",
            "type": "string"
        },
        {
            "name": "externalStatus",
            "baseName": "externalStatus",
            "type": "string"
        },
        {
            "name": "externalUpdated",
            "baseName": "externalUpdated",
            "type": "Date"
        },
        {
            "name": "interestRate",
            "baseName": "interestRate",
            "type": "number"
        },
        {
            "name": "linkId",
            "baseName": "linkId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccountCreateRequest.attributeTypeMap;
    }
}

export class AccountLink {
    'bankId'?: number;
    'created'?: Date;
    'encryptionKey'?: EncryptionKey;
    'externalUpdated'?: Date;
    'forceRefreshed'?: Date;
    'id'?: string;
    'loginForm'?: string;
    'memberId'?: string;
    'providerAccountId'?: number;
    'refreshActionRequired'?: string;
    'refreshAdditional'?: string;
    'refreshMessage'?: string;
    'refreshStatus'?: string;
    'refreshStatusCode'?: number;
    'status'?: AccountLink.StatusEnum;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bankId",
            "baseName": "bankId",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "encryptionKey",
            "baseName": "encryptionKey",
            "type": "EncryptionKey"
        },
        {
            "name": "externalUpdated",
            "baseName": "externalUpdated",
            "type": "Date"
        },
        {
            "name": "forceRefreshed",
            "baseName": "forceRefreshed",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "loginForm",
            "baseName": "loginForm",
            "type": "string"
        },
        {
            "name": "memberId",
            "baseName": "memberId",
            "type": "string"
        },
        {
            "name": "providerAccountId",
            "baseName": "providerAccountId",
            "type": "number"
        },
        {
            "name": "refreshActionRequired",
            "baseName": "refreshActionRequired",
            "type": "string"
        },
        {
            "name": "refreshAdditional",
            "baseName": "refreshAdditional",
            "type": "string"
        },
        {
            "name": "refreshMessage",
            "baseName": "refreshMessage",
            "type": "string"
        },
        {
            "name": "refreshStatus",
            "baseName": "refreshStatus",
            "type": "string"
        },
        {
            "name": "refreshStatusCode",
            "baseName": "refreshStatusCode",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "AccountLink.StatusEnum"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return AccountLink.attributeTypeMap;
    }
}

export namespace AccountLink {
    export enum StatusEnum {
        PENDING = <any> 'PENDING',
        LINKED = <any> 'LINKED',
        FAILED = <any> 'FAILED'
    }
}
export class AccountLinkCreateOrUpdateRequest {
    'bankId'?: number;
    'externalUpdated'?: Date;
    'loginForm'?: string;
    'providerAccountId'?: number;
    'refreshActionRequired'?: string;
    'refreshAdditional'?: string;
    'refreshMessage'?: string;
    'refreshStatus'?: string;
    'refreshStatusCode'?: number;
    'status'?: AccountLinkCreateOrUpdateRequest.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bankId",
            "baseName": "bankId",
            "type": "number"
        },
        {
            "name": "externalUpdated",
            "baseName": "externalUpdated",
            "type": "Date"
        },
        {
            "name": "loginForm",
            "baseName": "loginForm",
            "type": "string"
        },
        {
            "name": "providerAccountId",
            "baseName": "providerAccountId",
            "type": "number"
        },
        {
            "name": "refreshActionRequired",
            "baseName": "refreshActionRequired",
            "type": "string"
        },
        {
            "name": "refreshAdditional",
            "baseName": "refreshAdditional",
            "type": "string"
        },
        {
            "name": "refreshMessage",
            "baseName": "refreshMessage",
            "type": "string"
        },
        {
            "name": "refreshStatus",
            "baseName": "refreshStatus",
            "type": "string"
        },
        {
            "name": "refreshStatusCode",
            "baseName": "refreshStatusCode",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "AccountLinkCreateOrUpdateRequest.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return AccountLinkCreateOrUpdateRequest.attributeTypeMap;
    }
}

export namespace AccountLinkCreateOrUpdateRequest {
    export enum StatusEnum {
        PENDING = <any> 'PENDING',
        LINKED = <any> 'LINKED',
        FAILED = <any> 'FAILED'
    }
}
export class AccountLinkCreateRequest {
    'loginForm'?: YodleeProviderLoginFormRequest;
    'providerId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loginForm",
            "baseName": "loginForm",
            "type": "YodleeProviderLoginFormRequest"
        },
        {
            "name": "providerId",
            "baseName": "providerId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AccountLinkCreateRequest.attributeTypeMap;
    }
}

export class AccountLinkCredentialUpdateRequest {
    'loginForm'?: YodleeProviderLoginFormRequest;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loginForm",
            "baseName": "loginForm",
            "type": "YodleeProviderLoginFormRequest"
        }    ];

    static getAttributeTypeMap() {
        return AccountLinkCredentialUpdateRequest.attributeTypeMap;
    }
}

export class AccountLinkResponse {
    'accountLink'?: AccountLink;
    'fastlinkSession'?: FastlinkSession;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountLink",
            "baseName": "accountLink",
            "type": "AccountLink"
        },
        {
            "name": "fastlinkSession",
            "baseName": "fastlinkSession",
            "type": "FastlinkSession"
        }    ];

    static getAttributeTypeMap() {
        return AccountLinkResponse.attributeTypeMap;
    }
}

export class AccountLinkUpdateRequest {
    'forceRefreshed'?: Date;
    'status'?: AccountLinkUpdateRequest.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "forceRefreshed",
            "baseName": "forceRefreshed",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "AccountLinkUpdateRequest.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return AccountLinkUpdateRequest.attributeTypeMap;
    }
}

export namespace AccountLinkUpdateRequest {
    export enum StatusEnum {
        PENDING = <any> 'PENDING',
        LINKED = <any> 'LINKED',
        FAILED = <any> 'FAILED'
    }
}
export class AccountUpdateRequest {
    'accountName'?: string;
    'accountNumber'?: string;
    'accountType'?: string;
    'availableBalance'?: number;
    'balance'?: number;
    'clusterCompleted'?: Date;
    'container'?: string;
    'displayName'?: string;
    'externalStatus'?: string;
    'externalUpdated'?: Date;
    'transactionStatus'?: AccountUpdateRequest.TransactionStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountName",
            "baseName": "accountName",
            "type": "string"
        },
        {
            "name": "accountNumber",
            "baseName": "accountNumber",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "accountType",
            "type": "string"
        },
        {
            "name": "availableBalance",
            "baseName": "availableBalance",
            "type": "number"
        },
        {
            "name": "balance",
            "baseName": "balance",
            "type": "number"
        },
        {
            "name": "clusterCompleted",
            "baseName": "clusterCompleted",
            "type": "Date"
        },
        {
            "name": "container",
            "baseName": "container",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "externalStatus",
            "baseName": "externalStatus",
            "type": "string"
        },
        {
            "name": "externalUpdated",
            "baseName": "externalUpdated",
            "type": "Date"
        },
        {
            "name": "transactionStatus",
            "baseName": "transactionStatus",
            "type": "AccountUpdateRequest.TransactionStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return AccountUpdateRequest.attributeTypeMap;
    }
}

export namespace AccountUpdateRequest {
    export enum TransactionStatusEnum {
        NOTSTARTED = <any> 'NOT_STARTED',
        STARTED = <any> 'STARTED',
        DONE = <any> 'DONE',
        FAILED = <any> 'FAILED',
        UPDATING = <any> 'UPDATING'
    }
}
export class AccountUpdatedCountResponse {
    'numNotUpdated'?: number;
    'numUpdated'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "numNotUpdated",
            "baseName": "numNotUpdated",
            "type": "number"
        },
        {
            "name": "numUpdated",
            "baseName": "numUpdated",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AccountUpdatedCountResponse.attributeTypeMap;
    }
}

export class BasicHealth {
    'status'?: string;
    'statusCode'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "statusCode",
            "baseName": "statusCode",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return BasicHealth.attributeTypeMap;
    }
}

export class BasiqBearerToken {
    'bearerToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bearerToken",
            "baseName": "bearerToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BasiqBearerToken.attributeTypeMap;
    }
}

export class CalendarDismissedCreateRequest {
    'transactionId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CalendarDismissedCreateRequest.attributeTypeMap;
    }
}

export class CalendarDismissedResponse {
    'accountId'?: string;
    'amount'?: number;
    'created'?: Date;
    'description'?: string;
    'descriptionSimple'?: string;
    'id'?: string;
    'initialTransactionDate'?: string;
    'memberId'?: string;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "descriptionSimple",
            "baseName": "descriptionSimple",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "initialTransactionDate",
            "baseName": "initialTransactionDate",
            "type": "string"
        },
        {
            "name": "memberId",
            "baseName": "memberId",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return CalendarDismissedResponse.attributeTypeMap;
    }
}

export class CalendarEvent {
    'accountId'?: string;
    'amount'?: number;
    'calendarItemId'?: string;
    'categoryId'?: number;
    'date'?: string;
    'expected'?: number;
    'overdue'?: boolean;
    'suggested'?: boolean;
    'title'?: string;
    'transactionId'?: string;
    'type'?: CalendarEvent.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "calendarItemId",
            "baseName": "calendarItemId",
            "type": "string"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "expected",
            "baseName": "expected",
            "type": "number"
        },
        {
            "name": "overdue",
            "baseName": "overdue",
            "type": "boolean"
        },
        {
            "name": "suggested",
            "baseName": "suggested",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CalendarEvent.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CalendarEvent.attributeTypeMap;
    }
}

export namespace CalendarEvent {
    export enum TypeEnum {
        INCOME = <any> 'INCOME',
        BILL = <any> 'BILL'
    }
}
export class CalendarItemCreateRequest {
    /**
    * Default account if this has no events
    */
    'accountId'?: string;
    /**
    * Expected amount if this has no events
    */
    'amount'?: number;
    /**
    * Default category ID
    */
    'categoryId'?: number;
    'frequency': CalendarItemCreateRequest.FrequencyEnum;
    'name'?: string;
    /**
    * Next due date for the Item
    */
    'nextDueDate'?: string;
    /**
    * Is this a suggested event?
    */
    'suggested'?: boolean;
    /**
    * A single transaction ID, kept for backwards compatibility
    */
    'transactionId'?: string;
    /**
    * If these are provided, the transactionId property will be ignored
    */
    'transactionIds'?: Array<string>;
    'type': CalendarItemCreateRequest.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "CalendarItemCreateRequest.FrequencyEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nextDueDate",
            "baseName": "nextDueDate",
            "type": "string"
        },
        {
            "name": "suggested",
            "baseName": "suggested",
            "type": "boolean"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "transactionIds",
            "baseName": "transactionIds",
            "type": "Array<string>"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CalendarItemCreateRequest.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CalendarItemCreateRequest.attributeTypeMap;
    }
}

export namespace CalendarItemCreateRequest {
    export enum FrequencyEnum {
        ONCEOFF = <any> 'ONCE_OFF',
        WEEKLY = <any> 'WEEKLY',
        FORTNIGHTLY = <any> 'FORTNIGHTLY',
        MONTHLY = <any> 'MONTHLY',
        QUARTERLY = <any> 'QUARTERLY',
        YEARLY = <any> 'YEARLY'
    }
    export enum TypeEnum {
        INCOME = <any> 'INCOME',
        BILL = <any> 'BILL'
    }
}
export class CalendarItemMatcherResponse {
    'accountId'?: string;
    'amount'?: number;
    'calendarItemId': string;
    'created'?: Date;
    'description'?: string;
    'descriptionSimple'?: string;
    'id': string;
    'initialTransactionDate'?: string;
    'pending'?: boolean;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "calendarItemId",
            "baseName": "calendarItemId",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "descriptionSimple",
            "baseName": "descriptionSimple",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "initialTransactionDate",
            "baseName": "initialTransactionDate",
            "type": "string"
        },
        {
            "name": "pending",
            "baseName": "pending",
            "type": "boolean"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return CalendarItemMatcherResponse.attributeTypeMap;
    }
}

export class CalendarItemResponse {
    /**
    * Default account ID if this Item currently has no events
    */
    'accountId'?: string;
    /**
    * Expected amount if this Item currently has no events
    */
    'amount'?: number;
    /**
    * Default category ID
    */
    'categoryId'?: number;
    'frequency': CalendarItemResponse.FrequencyEnum;
    'id': string;
    'name': string;
    /**
    * Next due date that is set explicitly by a member
    */
    'nextDueDate'?: string;
    /**
    * Next forecast event, included only when querying for DETAILS
    */
    'nextEvent'?: CalendarEvent;
    /**
    * Most recent paid event, included only when querying for DETAILS
    */
    'previousEvent'?: CalendarEvent;
    /**
    * True once initial matching of all existing transactions is complete
    */
    'processed'?: boolean;
    'status': CalendarItemResponse.StatusEnum;
    /**
    * True if item is suggested
    */
    'suggested'?: boolean;
    /**
    * Number of transactions linked to this calendar Item
    */
    'transactionCount'?: number;
    'type': CalendarItemResponse.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "CalendarItemResponse.FrequencyEnum"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nextDueDate",
            "baseName": "nextDueDate",
            "type": "string"
        },
        {
            "name": "nextEvent",
            "baseName": "nextEvent",
            "type": "CalendarEvent"
        },
        {
            "name": "previousEvent",
            "baseName": "previousEvent",
            "type": "CalendarEvent"
        },
        {
            "name": "processed",
            "baseName": "processed",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "CalendarItemResponse.StatusEnum"
        },
        {
            "name": "suggested",
            "baseName": "suggested",
            "type": "boolean"
        },
        {
            "name": "transactionCount",
            "baseName": "transactionCount",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CalendarItemResponse.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CalendarItemResponse.attributeTypeMap;
    }
}

export namespace CalendarItemResponse {
    export enum FrequencyEnum {
        ONCEOFF = <any> 'ONCE_OFF',
        WEEKLY = <any> 'WEEKLY',
        FORTNIGHTLY = <any> 'FORTNIGHTLY',
        MONTHLY = <any> 'MONTHLY',
        QUARTERLY = <any> 'QUARTERLY',
        YEARLY = <any> 'YEARLY'
    }
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        ARCHIVE = <any> 'ARCHIVE'
    }
    export enum TypeEnum {
        INCOME = <any> 'INCOME',
        BILL = <any> 'BILL'
    }
}
export class CalendarItemUpdateRequest {
    /**
    * Default account if this has no events
    */
    'accountId'?: string;
    /**
    * Expected amount if this Item currently has no events
    */
    'amount'?: number;
    /**
    * Default category ID
    */
    'categoryId'?: number;
    'frequency'?: CalendarItemUpdateRequest.FrequencyEnum;
    'name'?: string;
    /**
    * Next due date that is set explicitly by a member
    */
    'nextDueDate'?: string;
    /**
    * Set to true once backend matching has completed
    */
    'processed'?: boolean;
    'status'?: CalendarItemUpdateRequest.StatusEnum;
    /**
    * Set to false when member accepts a suggestion
    */
    'suggested'?: boolean;
    'type'?: CalendarItemUpdateRequest.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "CalendarItemUpdateRequest.FrequencyEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nextDueDate",
            "baseName": "nextDueDate",
            "type": "string"
        },
        {
            "name": "processed",
            "baseName": "processed",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "CalendarItemUpdateRequest.StatusEnum"
        },
        {
            "name": "suggested",
            "baseName": "suggested",
            "type": "boolean"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CalendarItemUpdateRequest.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CalendarItemUpdateRequest.attributeTypeMap;
    }
}

export namespace CalendarItemUpdateRequest {
    export enum FrequencyEnum {
        ONCEOFF = <any> 'ONCE_OFF',
        WEEKLY = <any> 'WEEKLY',
        FORTNIGHTLY = <any> 'FORTNIGHTLY',
        MONTHLY = <any> 'MONTHLY',
        QUARTERLY = <any> 'QUARTERLY',
        YEARLY = <any> 'YEARLY'
    }
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        ARCHIVE = <any> 'ARCHIVE'
    }
    export enum TypeEnum {
        INCOME = <any> 'INCOME',
        BILL = <any> 'BILL'
    }
}
export class Categories {
    'created'?: Date;
    'description'?: string;
    'displayOrder'?: number;
    'id'?: number;
    'name'?: string;
    'parentId'?: string;
    'suggestAsEvent'?: boolean;
    'type'?: string;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "displayOrder",
            "baseName": "displayOrder",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        },
        {
            "name": "suggestAsEvent",
            "baseName": "suggestAsEvent",
            "type": "boolean"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Categories.attributeTypeMap;
    }
}

export class CategoryMappingResponse {
    'categoryId'?: number;
    'externalId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "externalId",
            "baseName": "externalId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CategoryMappingResponse.attributeTypeMap;
    }
}

export class CategoryMatcherRequest {
    'accountId': string;
    'amount'?: number;
    'categoryId': number;
    'description': string;
    'descriptionSimple'?: string;
    /**
    * created from pending transaction
    */
    'pending': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "descriptionSimple",
            "baseName": "descriptionSimple",
            "type": "string"
        },
        {
            "name": "pending",
            "baseName": "pending",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CategoryMatcherRequest.attributeTypeMap;
    }
}

export class CategoryMatcherResponse {
    'accountId'?: string;
    'amount'?: number;
    'categoryId'?: number;
    'created'?: Date;
    'description'?: string;
    'descriptionSimple'?: string;
    'global'?: boolean;
    'id'?: string;
    'pending'?: boolean;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "descriptionSimple",
            "baseName": "descriptionSimple",
            "type": "string"
        },
        {
            "name": "global",
            "baseName": "global",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "pending",
            "baseName": "pending",
            "type": "boolean"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return CategoryMatcherResponse.attributeTypeMap;
    }
}

export class EncryptionKey {
    'alias'?: string;
    'key'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EncryptionKey.attributeTypeMap;
    }
}

export class ExternalCategoryRequest {
    'description'?: string;
    'externalId'?: string;
    'name'?: string;
    'parentId'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "externalId",
            "baseName": "externalId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExternalCategoryRequest.attributeTypeMap;
    }
}

export class ExternalCategoryResponse {
    'description'?: string;
    'externalId'?: string;
    'externalProviderId'?: number;
    'name'?: string;
    'parentId'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "externalId",
            "baseName": "externalId",
            "type": "string"
        },
        {
            "name": "externalProviderId",
            "baseName": "externalProviderId",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExternalCategoryResponse.attributeTypeMap;
    }
}

export class FastlinkSession {
    'fields'?: Array<Field>;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fields",
            "baseName": "fields",
            "type": "Array<Field>"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FastlinkSession.attributeTypeMap;
    }
}

export class Field {
    'name'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Field.attributeTypeMap;
    }
}

export class GetAccountsResponse {
    'account'?: Array<YodleeAccount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "account",
            "baseName": "account",
            "type": "Array<YodleeAccount>"
        }    ];

    static getAttributeTypeMap() {
        return GetAccountsResponse.attributeTypeMap;
    }
}

export class Mapintlong extends null<String, number> {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Mapintlong.attributeTypeMap);
    }
}

export class PageAccountLink {
    'content'?: Array<AccountLink>;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: Pageable;
    'size'?: number;
    'sort'?: Sort;
    'totalElements'?: number;
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<AccountLink>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "pageable",
            "baseName": "pageable",
            "type": "Pageable"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageAccountLink.attributeTypeMap;
    }
}

export class PageCalendarDismissedResponse {
    'content'?: Array<CalendarDismissedResponse>;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: Pageable;
    'size'?: number;
    'sort'?: Sort;
    'totalElements'?: number;
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<CalendarDismissedResponse>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "pageable",
            "baseName": "pageable",
            "type": "Pageable"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageCalendarDismissedResponse.attributeTypeMap;
    }
}

export class PageCalendarEvent {
    'content'?: Array<CalendarEvent>;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: Pageable;
    'size'?: number;
    'sort'?: Sort;
    'totalElements'?: number;
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<CalendarEvent>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "pageable",
            "baseName": "pageable",
            "type": "Pageable"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageCalendarEvent.attributeTypeMap;
    }
}

export class PageCalendarItemMatcherResponse {
    'content'?: Array<CalendarItemMatcherResponse>;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: Pageable;
    'size'?: number;
    'sort'?: Sort;
    'totalElements'?: number;
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<CalendarItemMatcherResponse>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "pageable",
            "baseName": "pageable",
            "type": "Pageable"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageCalendarItemMatcherResponse.attributeTypeMap;
    }
}

export class PageCalendarItemResponse {
    'content'?: Array<CalendarItemResponse>;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: Pageable;
    'size'?: number;
    'sort'?: Sort;
    'totalElements'?: number;
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<CalendarItemResponse>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "pageable",
            "baseName": "pageable",
            "type": "Pageable"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageCalendarItemResponse.attributeTypeMap;
    }
}

export class PageCategoryMatcherResponse {
    'content'?: Array<CategoryMatcherResponse>;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: Pageable;
    'size'?: number;
    'sort'?: Sort;
    'totalElements'?: number;
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<CategoryMatcherResponse>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "pageable",
            "baseName": "pageable",
            "type": "Pageable"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageCategoryMatcherResponse.attributeTypeMap;
    }
}

export class PageSpendingOverrideResponse {
    'content'?: Array<SpendingOverrideResponse>;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: Pageable;
    'size'?: number;
    'sort'?: Sort;
    'totalElements'?: number;
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<SpendingOverrideResponse>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "pageable",
            "baseName": "pageable",
            "type": "Pageable"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageSpendingOverrideResponse.attributeTypeMap;
    }
}

export class PageSpendingTargetResponse {
    'content'?: Array<SpendingTargetResponse>;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: Pageable;
    'size'?: number;
    'sort'?: Sort;
    'totalElements'?: number;
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<SpendingTargetResponse>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "pageable",
            "baseName": "pageable",
            "type": "Pageable"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageSpendingTargetResponse.attributeTypeMap;
    }
}

export class PageTagResponse {
    'content'?: Array<TagResponse>;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'pageable'?: Pageable;
    'size'?: number;
    'sort'?: Sort;
    'totalElements'?: number;
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<TagResponse>"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "pageable",
            "baseName": "pageable",
            "type": "Pageable"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageTagResponse.attributeTypeMap;
    }
}

export class Pageable {
    'offset'?: number;
    'pageNumber'?: number;
    'pageSize'?: number;
    'paged'?: boolean;
    'sort'?: Sort;
    'unpaged'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "pageNumber",
            "baseName": "pageNumber",
            "type": "number"
        },
        {
            "name": "pageSize",
            "baseName": "pageSize",
            "type": "number"
        },
        {
            "name": "paged",
            "baseName": "paged",
            "type": "boolean"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "unpaged",
            "baseName": "unpaged",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Pageable.attributeTypeMap;
    }
}

export class PayCycle {
    'endingDate': string;
    'length': PayCycle.LengthEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "endingDate",
            "baseName": "endingDate",
            "type": "string"
        },
        {
            "name": "length",
            "baseName": "length",
            "type": "PayCycle.LengthEnum"
        }    ];

    static getAttributeTypeMap() {
        return PayCycle.attributeTypeMap;
    }
}

export namespace PayCycle {
    export enum LengthEnum {
        WEEK = <any> 'WEEK',
        FORTNIGHT = <any> 'FORTNIGHT',
        MONTH = <any> 'MONTH'
    }
}
export class ProviderAccount {
    'actionRequired'?: string;
    'additionalStatus'?: string;
    'createdDate'?: string;
    'id'?: number;
    'lastUpdated'?: Date;
    'loginForm'?: YodleeProviderLoginForm;
    'originalStatus'?: string;
    'providerId'?: number;
    'status'?: ProviderAccount.StatusEnum;
    'statusCode'?: number;
    'statusMessage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actionRequired",
            "baseName": "actionRequired",
            "type": "string"
        },
        {
            "name": "additionalStatus",
            "baseName": "additionalStatus",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "lastUpdated",
            "baseName": "lastUpdated",
            "type": "Date"
        },
        {
            "name": "loginForm",
            "baseName": "loginForm",
            "type": "YodleeProviderLoginForm"
        },
        {
            "name": "originalStatus",
            "baseName": "originalStatus",
            "type": "string"
        },
        {
            "name": "providerId",
            "baseName": "providerId",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "ProviderAccount.StatusEnum"
        },
        {
            "name": "statusCode",
            "baseName": "statusCode",
            "type": "number"
        },
        {
            "name": "statusMessage",
            "baseName": "statusMessage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProviderAccount.attributeTypeMap;
    }
}

export namespace ProviderAccount {
    export enum StatusEnum {
        SUCCESS = <any> 'SUCCESS',
        FAILURE = <any> 'FAILURE',
        PENDING = <any> 'PENDING'
    }
}
export class Sort {
    'sorted'?: boolean;
    'unsorted'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sorted",
            "baseName": "sorted",
            "type": "boolean"
        },
        {
            "name": "unsorted",
            "baseName": "unsorted",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Sort.attributeTypeMap;
    }
}

export class Spending {
    'amount'?: number;
    'count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Spending.attributeTypeMap;
    }
}

export class SpendingAccounts {
    'accounts'?: { [key: string]: SpendingCategories; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accounts",
            "baseName": "accounts",
            "type": "{ [key: string]: SpendingCategories; }"
        }    ];

    static getAttributeTypeMap() {
        return SpendingAccounts.attributeTypeMap;
    }
}

export class SpendingCategories {
    'categories'?: { [key: string]: Spending; };
    'pending'?: Spending;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categories",
            "baseName": "categories",
            "type": "{ [key: string]: Spending; }"
        },
        {
            "name": "pending",
            "baseName": "pending",
            "type": "Spending"
        }    ];

    static getAttributeTypeMap() {
        return SpendingCategories.attributeTypeMap;
    }
}

export class SpendingDailyResponse {
    'years'?: { [key: string]: SpendingMonthsByDay; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "years",
            "baseName": "years",
            "type": "{ [key: string]: SpendingMonthsByDay; }"
        }    ];

    static getAttributeTypeMap() {
        return SpendingDailyResponse.attributeTypeMap;
    }
}

export class SpendingDays {
    'days'?: { [key: string]: SpendingAccounts; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "days",
            "baseName": "days",
            "type": "{ [key: string]: SpendingAccounts; }"
        }    ];

    static getAttributeTypeMap() {
        return SpendingDays.attributeTypeMap;
    }
}

export class SpendingMonthWithAccounts {
    'months'?: { [key: string]: SpendingAccounts; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "months",
            "baseName": "months",
            "type": "{ [key: string]: SpendingAccounts; }"
        }    ];

    static getAttributeTypeMap() {
        return SpendingMonthWithAccounts.attributeTypeMap;
    }
}

export class SpendingMonthlyResponse {
    'years'?: { [key: string]: SpendingMonthWithAccounts; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "years",
            "baseName": "years",
            "type": "{ [key: string]: SpendingMonthWithAccounts; }"
        }    ];

    static getAttributeTypeMap() {
        return SpendingMonthlyResponse.attributeTypeMap;
    }
}

export class SpendingMonthsByDay {
    'months'?: { [key: string]: SpendingDays; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "months",
            "baseName": "months",
            "type": "{ [key: string]: SpendingDays; }"
        }    ];

    static getAttributeTypeMap() {
        return SpendingMonthsByDay.attributeTypeMap;
    }
}

export class SpendingOverrideBatchCreateUpdate {
    'applyToAll': boolean;
    'overrides': { [key: string]: number; };
    'payCycle': PayCycle;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applyToAll",
            "baseName": "applyToAll",
            "type": "boolean"
        },
        {
            "name": "overrides",
            "baseName": "overrides",
            "type": "{ [key: string]: number; }"
        },
        {
            "name": "payCycle",
            "baseName": "payCycle",
            "type": "PayCycle"
        }    ];

    static getAttributeTypeMap() {
        return SpendingOverrideBatchCreateUpdate.attributeTypeMap;
    }
}

export class SpendingOverrideResponse {
    'amount': number;
    'applyToAll': boolean;
    'categoryId': number;
    'id': string;
    'payCycle': PayCycle;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "applyToAll",
            "baseName": "applyToAll",
            "type": "boolean"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "payCycle",
            "baseName": "payCycle",
            "type": "PayCycle"
        }    ];

    static getAttributeTypeMap() {
        return SpendingOverrideResponse.attributeTypeMap;
    }
}

export class SpendingResponse {
    'totals'?: SpendingAccounts;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totals",
            "baseName": "totals",
            "type": "SpendingAccounts"
        }    ];

    static getAttributeTypeMap() {
        return SpendingResponse.attributeTypeMap;
    }
}

export class SpendingTargetCreateRequest {
    'amount': number;
    'categoryId': number;
    'period': SpendingTargetCreateRequest.PeriodEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "period",
            "baseName": "period",
            "type": "SpendingTargetCreateRequest.PeriodEnum"
        }    ];

    static getAttributeTypeMap() {
        return SpendingTargetCreateRequest.attributeTypeMap;
    }
}

export namespace SpendingTargetCreateRequest {
    export enum PeriodEnum {
        WEEK = <any> 'WEEK',
        MONTH = <any> 'MONTH'
    }
}
export class SpendingTargetResponse {
    'amount': number;
    'categoryId': number;
    'id': string;
    'period': SpendingTargetResponse.PeriodEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "period",
            "baseName": "period",
            "type": "SpendingTargetResponse.PeriodEnum"
        }    ];

    static getAttributeTypeMap() {
        return SpendingTargetResponse.attributeTypeMap;
    }
}

export namespace SpendingTargetResponse {
    export enum PeriodEnum {
        WEEK = <any> 'WEEK',
        MONTH = <any> 'MONTH'
    }
}
export class SpendingTargetUpdateRequest {
    'amount'?: number;
    'categoryId'?: number;
    'period'?: SpendingTargetUpdateRequest.PeriodEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "period",
            "baseName": "period",
            "type": "SpendingTargetUpdateRequest.PeriodEnum"
        }    ];

    static getAttributeTypeMap() {
        return SpendingTargetUpdateRequest.attributeTypeMap;
    }
}

export namespace SpendingTargetUpdateRequest {
    export enum PeriodEnum {
        WEEK = <any> 'WEEK',
        MONTH = <any> 'MONTH'
    }
}
export class TagRequest {
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TagRequest.attributeTypeMap;
    }
}

export class TagResponse {
    'id'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TagResponse.attributeTypeMap;
    }
}

export class TransactionClusterRequest {
    'frequency': TransactionClusterRequest.FrequencyEnum;
    'score': number;
    'transactionIds': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "TransactionClusterRequest.FrequencyEnum"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        },
        {
            "name": "transactionIds",
            "baseName": "transactionIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionClusterRequest.attributeTypeMap;
    }
}

export namespace TransactionClusterRequest {
    export enum FrequencyEnum {
        WEEKLY = <any> 'WEEKLY',
        FORTNIGHTLY = <any> 'FORTNIGHTLY',
        MONTHLY = <any> 'MONTHLY',
        QUARTERLY = <any> 'QUARTERLY',
        YEARLY = <any> 'YEARLY'
    }
}
export class TransactionClusterResponse {
    'calendarItemId': string;
    'frequency': TransactionClusterResponse.FrequencyEnum;
    'id': string;
    'memberId': string;
    'score': number;
    'transactions': Array<TransactionClusterTransactionResponse>;
    'type': TransactionClusterResponse.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "calendarItemId",
            "baseName": "calendarItemId",
            "type": "string"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "TransactionClusterResponse.FrequencyEnum"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "memberId",
            "baseName": "memberId",
            "type": "string"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        },
        {
            "name": "transactions",
            "baseName": "transactions",
            "type": "Array<TransactionClusterTransactionResponse>"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "TransactionClusterResponse.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return TransactionClusterResponse.attributeTypeMap;
    }
}

export namespace TransactionClusterResponse {
    export enum FrequencyEnum {
        WEEKLY = <any> 'WEEKLY',
        FORTNIGHTLY = <any> 'FORTNIGHTLY',
        MONTHLY = <any> 'MONTHLY',
        QUARTERLY = <any> 'QUARTERLY',
        YEARLY = <any> 'YEARLY'
    }
    export enum TypeEnum {
        EXPENSE = <any> 'EXPENSE',
        INCOME = <any> 'INCOME'
    }
}
export class TransactionClusterTransactionResponse {
    'id': string;
    'transaction'?: TransactionResponse;
    'transactionId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "transaction",
            "baseName": "transaction",
            "type": "TransactionResponse"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TransactionClusterTransactionResponse.attributeTypeMap;
    }
}

export class TransactionClusterUpdateRequest {
    'score'?: number;
    'transactionIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        },
        {
            "name": "transactionIds",
            "baseName": "transactionIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionClusterUpdateRequest.attributeTypeMap;
    }
}

export class TransactionCountResponse {
    'count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TransactionCountResponse.attributeTypeMap;
    }
}

export class TransactionPage {
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'size'?: number;
    'sort'?: Sort;
    'totalElements'?: number;
    'totalPages'?: number;
    'transactions'?: Array<TransactionResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "first",
            "baseName": "first",
            "type": "boolean"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "numberOfElements",
            "baseName": "numberOfElements",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Sort"
        },
        {
            "name": "totalElements",
            "baseName": "totalElements",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "totalPages",
            "type": "number"
        },
        {
            "name": "transactions",
            "baseName": "transactions",
            "type": "Array<TransactionResponse>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionPage.attributeTypeMap;
    }
}

export class TransactionRequest {
    'accountId'?: string;
    'amount'?: number;
    'categoryId'?: number;
    'createdDate'?: Date;
    'date'?: string;
    'description'?: string;
    'descriptionSimple'?: string;
    'externalCategoryId'?: string;
    'externalId'?: number;
    'lastUpdated'?: Date;
    'merchantId'?: string;
    'postDate'?: string;
    'runningBalance'?: number;
    'status'?: TransactionRequest.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "descriptionSimple",
            "baseName": "descriptionSimple",
            "type": "string"
        },
        {
            "name": "externalCategoryId",
            "baseName": "externalCategoryId",
            "type": "string"
        },
        {
            "name": "externalId",
            "baseName": "externalId",
            "type": "number"
        },
        {
            "name": "lastUpdated",
            "baseName": "lastUpdated",
            "type": "Date"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "postDate",
            "baseName": "postDate",
            "type": "string"
        },
        {
            "name": "runningBalance",
            "baseName": "runningBalance",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "TransactionRequest.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return TransactionRequest.attributeTypeMap;
    }
}

export namespace TransactionRequest {
    export enum StatusEnum {
        POSTED = <any> 'POSTED',
        PENDING = <any> 'PENDING',
        SCHEDULED = <any> 'SCHEDULED',
        DELETED = <any> 'DELETED'
    }
}
export class TransactionResponse {
    'accountId'?: string;
    'amount'?: number;
    'calendarItemId'?: string;
    'categoryId'?: number;
    'created'?: Date;
    'date'?: string;
    'description'?: string;
    'descriptionSimple'?: string;
    'dismissedAsEvent'?: boolean;
    'externalId'?: number;
    'id'?: string;
    'memberId'?: string;
    'merchantId'?: string;
    'postDate'?: string;
    'runningBalance'?: number;
    'status'?: TransactionResponse.StatusEnum;
    'tagIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "calendarItemId",
            "baseName": "calendarItemId",
            "type": "string"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "descriptionSimple",
            "baseName": "descriptionSimple",
            "type": "string"
        },
        {
            "name": "dismissedAsEvent",
            "baseName": "dismissedAsEvent",
            "type": "boolean"
        },
        {
            "name": "externalId",
            "baseName": "externalId",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "memberId",
            "baseName": "memberId",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "postDate",
            "baseName": "postDate",
            "type": "string"
        },
        {
            "name": "runningBalance",
            "baseName": "runningBalance",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "TransactionResponse.StatusEnum"
        },
        {
            "name": "tagIds",
            "baseName": "tagIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionResponse.attributeTypeMap;
    }
}

export namespace TransactionResponse {
    export enum StatusEnum {
        POSTED = <any> 'POSTED',
        PENDING = <any> 'PENDING',
        SCHEDULED = <any> 'SCHEDULED',
        DELETED = <any> 'DELETED'
    }
}
export class TransactionUpdateRequest {
    'calendarItemId'?: string;
    'categoryId'?: number;
    'dismissedAsEvent'?: boolean;
    'id'?: string;
    'removeCalendarItemId'?: boolean;
    'tagIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "calendarItemId",
            "baseName": "calendarItemId",
            "type": "string"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "dismissedAsEvent",
            "baseName": "dismissedAsEvent",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "removeCalendarItemId",
            "baseName": "removeCalendarItemId",
            "type": "boolean"
        },
        {
            "name": "tagIds",
            "baseName": "tagIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionUpdateRequest.attributeTypeMap;
    }
}

export class YodleeAccount {
    'CONTAINER'?: string;
    'accountName'?: string;
    'accountNumber'?: string;
    'accountStatus'?: string;
    'accountType'?: string;
    'amountDue'?: YodleeMoney;
    'annuityBalance'?: string;
    'apr'?: string;
    'availableBalance'?: YodleeMoney;
    'availableCash'?: YodleeMoney;
    'availableCredit'?: YodleeMoney;
    'availableLoan'?: string;
    'balance'?: YodleeMoney;
    'bankTransferCode'?: Array<YodleeBankTransferCode>;
    'cash'?: YodleeMoney;
    'classification'?: string;
    'currency'?: string;
    'currentBalance'?: YodleeMoney;
    'dueDate'?: string;
    'enrollmentDate'?: string;
    'errorCode'?: string;
    'expirationDate'?: string;
    'id'?: string;
    'interestRate'?: string;
    'investmentPlan'?: YodleeInvestmentPlan;
    'isAsset'?: string;
    'isManual'?: string;
    'lastPaymentAmount'?: string;
    'lastPaymentDate'?: string;
    'lastUpdated'?: string;
    'marginBalance'?: YodleeMoney;
    'maturityDate'?: string;
    'minimumAmountDue'?: YodleeMoney;
    'nickname'?: string;
    'originalLoanAmount'?: YodleeMoney;
    'primaryRewardUnit'?: string;
    'providerAccountId'?: string;
    'providerId'?: string;
    'providerName'?: string;
    'refreshinfo'?: YodleeRefreshInfo;
    'routingNumber'?: string;
    'runningBalance'?: string;
    'term'?: string;
    'totalInvestedAmount'?: YodleeMoney;
    'totalUnvestedBalance'?: YodleeMoney;
    'totalVestedBalance'?: YodleeMoney;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CONTAINER",
            "baseName": "CONTAINER",
            "type": "string"
        },
        {
            "name": "accountName",
            "baseName": "accountName",
            "type": "string"
        },
        {
            "name": "accountNumber",
            "baseName": "accountNumber",
            "type": "string"
        },
        {
            "name": "accountStatus",
            "baseName": "accountStatus",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "accountType",
            "type": "string"
        },
        {
            "name": "amountDue",
            "baseName": "amountDue",
            "type": "YodleeMoney"
        },
        {
            "name": "annuityBalance",
            "baseName": "annuityBalance",
            "type": "string"
        },
        {
            "name": "apr",
            "baseName": "apr",
            "type": "string"
        },
        {
            "name": "availableBalance",
            "baseName": "availableBalance",
            "type": "YodleeMoney"
        },
        {
            "name": "availableCash",
            "baseName": "availableCash",
            "type": "YodleeMoney"
        },
        {
            "name": "availableCredit",
            "baseName": "availableCredit",
            "type": "YodleeMoney"
        },
        {
            "name": "availableLoan",
            "baseName": "availableLoan",
            "type": "string"
        },
        {
            "name": "balance",
            "baseName": "balance",
            "type": "YodleeMoney"
        },
        {
            "name": "bankTransferCode",
            "baseName": "bankTransferCode",
            "type": "Array<YodleeBankTransferCode>"
        },
        {
            "name": "cash",
            "baseName": "cash",
            "type": "YodleeMoney"
        },
        {
            "name": "classification",
            "baseName": "classification",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "currentBalance",
            "baseName": "currentBalance",
            "type": "YodleeMoney"
        },
        {
            "name": "dueDate",
            "baseName": "dueDate",
            "type": "string"
        },
        {
            "name": "enrollmentDate",
            "baseName": "enrollmentDate",
            "type": "string"
        },
        {
            "name": "errorCode",
            "baseName": "errorCode",
            "type": "string"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "interestRate",
            "baseName": "interestRate",
            "type": "string"
        },
        {
            "name": "investmentPlan",
            "baseName": "investmentPlan",
            "type": "YodleeInvestmentPlan"
        },
        {
            "name": "isAsset",
            "baseName": "isAsset",
            "type": "string"
        },
        {
            "name": "isManual",
            "baseName": "isManual",
            "type": "string"
        },
        {
            "name": "lastPaymentAmount",
            "baseName": "lastPaymentAmount",
            "type": "string"
        },
        {
            "name": "lastPaymentDate",
            "baseName": "lastPaymentDate",
            "type": "string"
        },
        {
            "name": "lastUpdated",
            "baseName": "lastUpdated",
            "type": "string"
        },
        {
            "name": "marginBalance",
            "baseName": "marginBalance",
            "type": "YodleeMoney"
        },
        {
            "name": "maturityDate",
            "baseName": "maturityDate",
            "type": "string"
        },
        {
            "name": "minimumAmountDue",
            "baseName": "minimumAmountDue",
            "type": "YodleeMoney"
        },
        {
            "name": "nickname",
            "baseName": "nickname",
            "type": "string"
        },
        {
            "name": "originalLoanAmount",
            "baseName": "originalLoanAmount",
            "type": "YodleeMoney"
        },
        {
            "name": "primaryRewardUnit",
            "baseName": "primaryRewardUnit",
            "type": "string"
        },
        {
            "name": "providerAccountId",
            "baseName": "providerAccountId",
            "type": "string"
        },
        {
            "name": "providerId",
            "baseName": "providerId",
            "type": "string"
        },
        {
            "name": "providerName",
            "baseName": "providerName",
            "type": "string"
        },
        {
            "name": "refreshinfo",
            "baseName": "refreshinfo",
            "type": "YodleeRefreshInfo"
        },
        {
            "name": "routingNumber",
            "baseName": "routingNumber",
            "type": "string"
        },
        {
            "name": "runningBalance",
            "baseName": "runningBalance",
            "type": "string"
        },
        {
            "name": "term",
            "baseName": "term",
            "type": "string"
        },
        {
            "name": "totalInvestedAmount",
            "baseName": "totalInvestedAmount",
            "type": "YodleeMoney"
        },
        {
            "name": "totalUnvestedBalance",
            "baseName": "totalUnvestedBalance",
            "type": "YodleeMoney"
        },
        {
            "name": "totalVestedBalance",
            "baseName": "totalVestedBalance",
            "type": "YodleeMoney"
        }    ];

    static getAttributeTypeMap() {
        return YodleeAccount.attributeTypeMap;
    }
}

export class YodleeBankTransferCode {
    'id'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return YodleeBankTransferCode.attributeTypeMap;
    }
}

export class YodleeCobrandSession {
    'authorization'?: string;
    'baseUrl'?: string;
    'cobSession'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authorization",
            "baseName": "authorization",
            "type": "string"
        },
        {
            "name": "baseUrl",
            "baseName": "baseUrl",
            "type": "string"
        },
        {
            "name": "cobSession",
            "baseName": "cobSession",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return YodleeCobrandSession.attributeTypeMap;
    }
}

export class YodleeInvestmentOption {
    'cusipNumber'?: string;
    'description'?: string;
    'holdingType'?: string;
    'id'?: string;
    'isin'?: string;
    'price'?: YodleeMoney;
    'sedol'?: string;
    'symbol'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cusipNumber",
            "baseName": "cusipNumber",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "holdingType",
            "baseName": "holdingType",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isin",
            "baseName": "isin",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "YodleeMoney"
        },
        {
            "name": "sedol",
            "baseName": "sedol",
            "type": "string"
        },
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return YodleeInvestmentOption.attributeTypeMap;
    }
}

export class YodleeInvestmentPlan {
    'investmentOption'?: Array<YodleeInvestmentOption>;
    'planName'?: string;
    'planNumber'?: string;
    'providerId'?: string;
    'providerName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "investmentOption",
            "baseName": "investmentOption",
            "type": "Array<YodleeInvestmentOption>"
        },
        {
            "name": "planName",
            "baseName": "planName",
            "type": "string"
        },
        {
            "name": "planNumber",
            "baseName": "planNumber",
            "type": "string"
        },
        {
            "name": "providerId",
            "baseName": "providerId",
            "type": "string"
        },
        {
            "name": "providerName",
            "baseName": "providerName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return YodleeInvestmentPlan.attributeTypeMap;
    }
}

export class YodleeMoney {
    'amount'?: string;
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return YodleeMoney.attributeTypeMap;
    }
}

export class YodleeProvider {
    'authType'?: string;
    'encryptionKey'?: EncryptionKey;
    'id'?: number;
    'loginForm'?: YodleeProviderLoginForm;
    'loginHelp'?: string;
    'mfaType'?: string;
    'name'?: string;
    'oauthSite'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authType",
            "baseName": "authType",
            "type": "string"
        },
        {
            "name": "encryptionKey",
            "baseName": "encryptionKey",
            "type": "EncryptionKey"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "loginForm",
            "baseName": "loginForm",
            "type": "YodleeProviderLoginForm"
        },
        {
            "name": "loginHelp",
            "baseName": "loginHelp",
            "type": "string"
        },
        {
            "name": "mfaType",
            "baseName": "mfaType",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "oauthSite",
            "baseName": "oauthSite",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return YodleeProvider.attributeTypeMap;
    }
}

export class YodleeProviderLoginForm {
    'forgetPasswordURL'?: string;
    'formType'?: string;
    'help'?: string;
    'id'?: number;
    'mfaInfoText'?: string;
    'mfaInfoTitle'?: string;
    'mfaTimeout'?: number;
    'row'?: Array<YodleeProviderLoginFormRow>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "forgetPasswordURL",
            "baseName": "forgetPasswordURL",
            "type": "string"
        },
        {
            "name": "formType",
            "baseName": "formType",
            "type": "string"
        },
        {
            "name": "help",
            "baseName": "help",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "mfaInfoText",
            "baseName": "mfaInfoText",
            "type": "string"
        },
        {
            "name": "mfaInfoTitle",
            "baseName": "mfaInfoTitle",
            "type": "string"
        },
        {
            "name": "mfaTimeout",
            "baseName": "mfaTimeout",
            "type": "number"
        },
        {
            "name": "row",
            "baseName": "row",
            "type": "Array<YodleeProviderLoginFormRow>"
        }    ];

    static getAttributeTypeMap() {
        return YodleeProviderLoginForm.attributeTypeMap;
    }
}

export class YodleeProviderLoginFormRequest {
    'row'?: Array<YodleeProviderLoginFormRowRequest>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "row",
            "baseName": "row",
            "type": "Array<YodleeProviderLoginFormRowRequest>"
        }    ];

    static getAttributeTypeMap() {
        return YodleeProviderLoginFormRequest.attributeTypeMap;
    }
}

export class YodleeProviderLoginFormRow {
    'field'?: Array<YodleeProviderLoginFormRowField>;
    'fieldRowChoice'?: string;
    'form'?: string;
    'id'?: any;
    'label'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "Array<YodleeProviderLoginFormRowField>"
        },
        {
            "name": "fieldRowChoice",
            "baseName": "fieldRowChoice",
            "type": "string"
        },
        {
            "name": "form",
            "baseName": "form",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "any"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return YodleeProviderLoginFormRow.attributeTypeMap;
    }
}

export class YodleeProviderLoginFormRowField {
    'id'?: any;
    'image'?: string;
    'isOptional'?: boolean;
    'maxLength'?: number;
    'name'?: string;
    'option'?: Array<YodleeProviderLoginFormRowFieldOption>;
    'prefix'?: string;
    'suffix'?: string;
    'type'?: string;
    'validation'?: Array<YodleeProviderLoginFormRowFieldValidation>;
    'value'?: string;
    'valueEditable'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "any"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "isOptional",
            "baseName": "isOptional",
            "type": "boolean"
        },
        {
            "name": "maxLength",
            "baseName": "maxLength",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "option",
            "baseName": "option",
            "type": "Array<YodleeProviderLoginFormRowFieldOption>"
        },
        {
            "name": "prefix",
            "baseName": "prefix",
            "type": "string"
        },
        {
            "name": "suffix",
            "baseName": "suffix",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "validation",
            "baseName": "validation",
            "type": "Array<YodleeProviderLoginFormRowFieldValidation>"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "valueEditable",
            "baseName": "valueEditable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return YodleeProviderLoginFormRowField.attributeTypeMap;
    }
}

export class YodleeProviderLoginFormRowFieldOption {
    'displayText'?: string;
    'isSelected'?: boolean;
    'optionValue'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "displayText",
            "baseName": "displayText",
            "type": "string"
        },
        {
            "name": "isSelected",
            "baseName": "isSelected",
            "type": "boolean"
        },
        {
            "name": "optionValue",
            "baseName": "optionValue",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return YodleeProviderLoginFormRowFieldOption.attributeTypeMap;
    }
}

export class YodleeProviderLoginFormRowFieldRequest {
    'id'?: any;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "any"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return YodleeProviderLoginFormRowFieldRequest.attributeTypeMap;
    }
}

export class YodleeProviderLoginFormRowFieldValidation {
    'errorMsg'?: string;
    'regExp'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errorMsg",
            "baseName": "errorMsg",
            "type": "string"
        },
        {
            "name": "regExp",
            "baseName": "regExp",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return YodleeProviderLoginFormRowFieldValidation.attributeTypeMap;
    }
}

export class YodleeProviderLoginFormRowRequest {
    'field'?: Array<YodleeProviderLoginFormRowFieldRequest>;
    'label'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "Array<YodleeProviderLoginFormRowFieldRequest>"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return YodleeProviderLoginFormRowRequest.attributeTypeMap;
    }
}

export class YodleeRefreshInfo {
    'lastRefreshAttempt'?: string;
    'lastRefreshed'?: string;
    'nextRefreshScheduled'?: string;
    'refreshStatus'?: string;
    'status'?: string;
    'statusCode'?: string;
    'statusMessage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastRefreshAttempt",
            "baseName": "lastRefreshAttempt",
            "type": "string"
        },
        {
            "name": "lastRefreshed",
            "baseName": "lastRefreshed",
            "type": "string"
        },
        {
            "name": "nextRefreshScheduled",
            "baseName": "nextRefreshScheduled",
            "type": "string"
        },
        {
            "name": "refreshStatus",
            "baseName": "refreshStatus",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "statusCode",
            "baseName": "statusCode",
            "type": "string"
        },
        {
            "name": "statusMessage",
            "baseName": "statusMessage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return YodleeRefreshInfo.attributeTypeMap;
    }
}

export class YodleeUserSession {
    'authorization'?: string;
    'baseUrl'?: string;
    'cobSession'?: string;
    'userSession'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authorization",
            "baseName": "authorization",
            "type": "string"
        },
        {
            "name": "baseUrl",
            "baseName": "baseUrl",
            "type": "string"
        },
        {
            "name": "cobSession",
            "baseName": "cobSession",
            "type": "string"
        },
        {
            "name": "userSession",
            "baseName": "userSession",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return YodleeUserSession.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "Account.StatusEnum": Account.StatusEnum,
        "Account.TransactionStatusEnum": Account.TransactionStatusEnum,
        "AccountLink.StatusEnum": AccountLink.StatusEnum,
        "AccountLinkCreateOrUpdateRequest.StatusEnum": AccountLinkCreateOrUpdateRequest.StatusEnum,
        "AccountLinkUpdateRequest.StatusEnum": AccountLinkUpdateRequest.StatusEnum,
        "AccountUpdateRequest.TransactionStatusEnum": AccountUpdateRequest.TransactionStatusEnum,
        "CalendarEvent.TypeEnum": CalendarEvent.TypeEnum,
        "CalendarItemCreateRequest.FrequencyEnum": CalendarItemCreateRequest.FrequencyEnum,
        "CalendarItemCreateRequest.TypeEnum": CalendarItemCreateRequest.TypeEnum,
        "CalendarItemResponse.FrequencyEnum": CalendarItemResponse.FrequencyEnum,
        "CalendarItemResponse.StatusEnum": CalendarItemResponse.StatusEnum,
        "CalendarItemResponse.TypeEnum": CalendarItemResponse.TypeEnum,
        "CalendarItemUpdateRequest.FrequencyEnum": CalendarItemUpdateRequest.FrequencyEnum,
        "CalendarItemUpdateRequest.StatusEnum": CalendarItemUpdateRequest.StatusEnum,
        "CalendarItemUpdateRequest.TypeEnum": CalendarItemUpdateRequest.TypeEnum,
        "PayCycle.LengthEnum": PayCycle.LengthEnum,
        "ProviderAccount.StatusEnum": ProviderAccount.StatusEnum,
        "SpendingTargetCreateRequest.PeriodEnum": SpendingTargetCreateRequest.PeriodEnum,
        "SpendingTargetResponse.PeriodEnum": SpendingTargetResponse.PeriodEnum,
        "SpendingTargetUpdateRequest.PeriodEnum": SpendingTargetUpdateRequest.PeriodEnum,
        "TransactionClusterRequest.FrequencyEnum": TransactionClusterRequest.FrequencyEnum,
        "TransactionClusterResponse.FrequencyEnum": TransactionClusterResponse.FrequencyEnum,
        "TransactionClusterResponse.TypeEnum": TransactionClusterResponse.TypeEnum,
        "TransactionRequest.StatusEnum": TransactionRequest.StatusEnum,
        "TransactionResponse.StatusEnum": TransactionResponse.StatusEnum,
}

let typeMap: {[index: string]: any} = {
    "Account": Account,
    "AccountBalanceResponse": AccountBalanceResponse,
    "AccountCreateRequest": AccountCreateRequest,
    "AccountLink": AccountLink,
    "AccountLinkCreateOrUpdateRequest": AccountLinkCreateOrUpdateRequest,
    "AccountLinkCreateRequest": AccountLinkCreateRequest,
    "AccountLinkCredentialUpdateRequest": AccountLinkCredentialUpdateRequest,
    "AccountLinkResponse": AccountLinkResponse,
    "AccountLinkUpdateRequest": AccountLinkUpdateRequest,
    "AccountUpdateRequest": AccountUpdateRequest,
    "AccountUpdatedCountResponse": AccountUpdatedCountResponse,
    "BasicHealth": BasicHealth,
    "BasiqBearerToken": BasiqBearerToken,
    "CalendarDismissedCreateRequest": CalendarDismissedCreateRequest,
    "CalendarDismissedResponse": CalendarDismissedResponse,
    "CalendarEvent": CalendarEvent,
    "CalendarItemCreateRequest": CalendarItemCreateRequest,
    "CalendarItemMatcherResponse": CalendarItemMatcherResponse,
    "CalendarItemResponse": CalendarItemResponse,
    "CalendarItemUpdateRequest": CalendarItemUpdateRequest,
    "Categories": Categories,
    "CategoryMappingResponse": CategoryMappingResponse,
    "CategoryMatcherRequest": CategoryMatcherRequest,
    "CategoryMatcherResponse": CategoryMatcherResponse,
    "EncryptionKey": EncryptionKey,
    "ExternalCategoryRequest": ExternalCategoryRequest,
    "ExternalCategoryResponse": ExternalCategoryResponse,
    "FastlinkSession": FastlinkSession,
    "Field": Field,
    "GetAccountsResponse": GetAccountsResponse,
    "Mapintlong": Mapintlong,
    "PageAccountLink": PageAccountLink,
    "PageCalendarDismissedResponse": PageCalendarDismissedResponse,
    "PageCalendarEvent": PageCalendarEvent,
    "PageCalendarItemMatcherResponse": PageCalendarItemMatcherResponse,
    "PageCalendarItemResponse": PageCalendarItemResponse,
    "PageCategoryMatcherResponse": PageCategoryMatcherResponse,
    "PageSpendingOverrideResponse": PageSpendingOverrideResponse,
    "PageSpendingTargetResponse": PageSpendingTargetResponse,
    "PageTagResponse": PageTagResponse,
    "Pageable": Pageable,
    "PayCycle": PayCycle,
    "ProviderAccount": ProviderAccount,
    "Sort": Sort,
    "Spending": Spending,
    "SpendingAccounts": SpendingAccounts,
    "SpendingCategories": SpendingCategories,
    "SpendingDailyResponse": SpendingDailyResponse,
    "SpendingDays": SpendingDays,
    "SpendingMonthWithAccounts": SpendingMonthWithAccounts,
    "SpendingMonthlyResponse": SpendingMonthlyResponse,
    "SpendingMonthsByDay": SpendingMonthsByDay,
    "SpendingOverrideBatchCreateUpdate": SpendingOverrideBatchCreateUpdate,
    "SpendingOverrideResponse": SpendingOverrideResponse,
    "SpendingResponse": SpendingResponse,
    "SpendingTargetCreateRequest": SpendingTargetCreateRequest,
    "SpendingTargetResponse": SpendingTargetResponse,
    "SpendingTargetUpdateRequest": SpendingTargetUpdateRequest,
    "TagRequest": TagRequest,
    "TagResponse": TagResponse,
    "TransactionClusterRequest": TransactionClusterRequest,
    "TransactionClusterResponse": TransactionClusterResponse,
    "TransactionClusterTransactionResponse": TransactionClusterTransactionResponse,
    "TransactionClusterUpdateRequest": TransactionClusterUpdateRequest,
    "TransactionCountResponse": TransactionCountResponse,
    "TransactionPage": TransactionPage,
    "TransactionRequest": TransactionRequest,
    "TransactionResponse": TransactionResponse,
    "TransactionUpdateRequest": TransactionUpdateRequest,
    "YodleeAccount": YodleeAccount,
    "YodleeBankTransferCode": YodleeBankTransferCode,
    "YodleeCobrandSession": YodleeCobrandSession,
    "YodleeInvestmentOption": YodleeInvestmentOption,
    "YodleeInvestmentPlan": YodleeInvestmentPlan,
    "YodleeMoney": YodleeMoney,
    "YodleeProvider": YodleeProvider,
    "YodleeProviderLoginForm": YodleeProviderLoginForm,
    "YodleeProviderLoginFormRequest": YodleeProviderLoginFormRequest,
    "YodleeProviderLoginFormRow": YodleeProviderLoginFormRow,
    "YodleeProviderLoginFormRowField": YodleeProviderLoginFormRowField,
    "YodleeProviderLoginFormRowFieldOption": YodleeProviderLoginFormRowFieldOption,
    "YodleeProviderLoginFormRowFieldRequest": YodleeProviderLoginFormRowFieldRequest,
    "YodleeProviderLoginFormRowFieldValidation": YodleeProviderLoginFormRowFieldValidation,
    "YodleeProviderLoginFormRowRequest": YodleeProviderLoginFormRowRequest,
    "YodleeRefreshInfo": YodleeRefreshInfo,
    "YodleeUserSession": YodleeUserSession,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccountBalanceControllerApiApiKeys {
    identityId,
    identityRole,
}

export class AccountBalanceControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountBalanceControllerApiApiKeys, value: string) {
        (this.authentications as any)[AccountBalanceControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get account details
     * @param accountId 
     * @param fromDate 
     * @param toDate 
     */
    public getAccountByIdUsingGET (accountId?: Array<string>, fromDate?: string, toDate?: string) : Promise<{ response: http.IncomingMessage; body: Array<AccountBalanceResponse>;  }> {
        const localVarPath = this.basePath + '/accounts/balances';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "Array<string>");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['fromDate'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['toDate'] = ObjectSerializer.serialize(toDate, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<AccountBalanceResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AccountBalanceResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AccountControllerApiApiKeys {
    identityId,
    identityRole,
}

export class AccountControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountControllerApiApiKeys, value: string) {
        (this.authentications as any)[AccountControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Store account details
     * @param request request
     */
    public createAccountUsingPOST (request: AccountCreateRequest) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling createAccountUsingPOST.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "AccountCreateRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Account");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete bank account
     * @param accountId accountId
     */
    public deleteAccountByIdUsingDELETE (accountId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/accounts/{accountId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountByIdUsingDELETE.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Disable bank account
     * @param accountId accountId
     */
    public disableAccountByIdUsingPUT (accountId: string) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/accounts/{accountId}/disable'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling disableAccountByIdUsingPUT.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Account");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Enable bank account
     * @param accountId accountId
     */
    public enableAccountByIdUsingPUT (accountId: string) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/accounts/{accountId}/enable'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling enableAccountByIdUsingPUT.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Account");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get account details
     * @param status 
     * @param linkId 
     */
    public findAccountsUsingGET (status?: Array<'ACTIVE' | 'DISABLED'>, linkId?: string) : Promise<{ response: http.IncomingMessage; body: Array<Account>;  }> {
        const localVarPath = this.basePath + '/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'ACTIVE' | 'DISABLED'>");
        }

        if (linkId !== undefined) {
            localVarQueryParameters['linkId'] = ObjectSerializer.serialize(linkId, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Account>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Account>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get account details
     * @param id id
     */
    public getAccountByIdUsingGET1 (id: string) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/accounts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAccountByIdUsingGET1.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Account");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update bank account
     * @param request request
     * @param externalId externalId
     */
    public updateAccountByExternalIdUsingPUT (request: AccountUpdateRequest, externalId?: string) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling updateAccountByExternalIdUsingPUT.');
        }

        if (externalId !== undefined) {
            localVarQueryParameters['externalId'] = ObjectSerializer.serialize(externalId, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "AccountUpdateRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Account");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update bank account
     * @param id id
     * @param request request
     */
    public updateAccountByIdUsingPUT (id: string, request: AccountUpdateRequest) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/accounts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateAccountByIdUsingPUT.');
        }

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling updateAccountByIdUsingPUT.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "AccountUpdateRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Account");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AccountLinkControllerApiApiKeys {
    identityId,
    identityRole,
}

export class AccountLinkControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountLinkControllerApiApiKeys, value: string) {
        (this.authentications as any)[AccountLinkControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Archive all bank account links
     * @param guid guid
     */
    public archiveAccountByMemberIdUsingDELETE (guid: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/accounts/link/archive';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'guid' is not null or undefined
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling archiveAccountByMemberIdUsingDELETE.');
        }

        if (guid !== undefined) {
            localVarQueryParameters['guid'] = ObjectSerializer.serialize(guid, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Link bank account
     * @param bank bank
     */
    public createAccountLinkUsingPOST (bank: number) : Promise<{ response: http.IncomingMessage; body: AccountLinkResponse;  }> {
        const localVarPath = this.basePath + '/accounts/link';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'bank' is not null or undefined
        if (bank === null || bank === undefined) {
            throw new Error('Required parameter bank was null or undefined when calling createAccountLinkUsingPOST.');
        }

        if (bank !== undefined) {
            localVarQueryParameters['bank'] = ObjectSerializer.serialize(bank, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountLinkResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountLinkResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete bank account link
     * @param accountLinkId accountLinkId
     */
    public deleteAccountByIdUsingDELETE1 (accountLinkId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/accounts/link/{accountLinkId}'
            .replace('{' + 'accountLinkId' + '}', encodeURIComponent(String(accountLinkId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountLinkId' is not null or undefined
        if (accountLinkId === null || accountLinkId === undefined) {
            throw new Error('Required parameter accountLinkId was null or undefined when calling deleteAccountByIdUsingDELETE1.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get link status
     * @param id id
     */
    public getAccountLinkUsingGET (id: string) : Promise<{ response: http.IncomingMessage; body: AccountLink;  }> {
        const localVarPath = this.basePath + '/accounts/link/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAccountLinkUsingGET.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all account links
     * @param status 
     * @param excludedActionRequired 
     * @param updatedBefore External update time in ISO DateTime Format (like 2018-04-30T00:21:20.197Z)
     * @param forceRefreshedBefore Force refreshed time in ISO DateTime Format (like 2018-04-30T00:21:20.197Z)
     * @param page Results page you want to retrieve (0..N)
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     */
    public getAccountLinksUsingGET (status?: Array<'PENDING' | 'LINKED' | 'FAILED'>, excludedActionRequired?: Array<string>, updatedBefore?: Date, forceRefreshedBefore?: Date, page?: number, size?: number, sort?: Array<string>) : Promise<{ response: http.IncomingMessage; body: PageAccountLink;  }> {
        const localVarPath = this.basePath + '/accounts/link';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'PENDING' | 'LINKED' | 'FAILED'>");
        }

        if (excludedActionRequired !== undefined) {
            localVarQueryParameters['excludedActionRequired'] = ObjectSerializer.serialize(excludedActionRequired, "Array<string>");
        }

        if (updatedBefore !== undefined) {
            localVarQueryParameters['updatedBefore'] = ObjectSerializer.serialize(updatedBefore, "Date");
        }

        if (forceRefreshedBefore !== undefined) {
            localVarQueryParameters['forceRefreshedBefore'] = ObjectSerializer.serialize(forceRefreshedBefore, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PageAccountLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageAccountLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update bank account link
     * @param id id
     * @param request request
     */
    public updateAccountLinkUsingPUT (id: string, request: AccountLinkCreateOrUpdateRequest) : Promise<{ response: http.IncomingMessage; body: AccountLink;  }> {
        const localVarPath = this.basePath + '/accounts/link/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateAccountLinkUsingPUT.');
        }

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling updateAccountLinkUsingPUT.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "AccountLinkCreateOrUpdateRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AccountLinksControllerApiApiKeys {
    identityId,
    identityRole,
}

export class AccountLinksControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountLinksControllerApiApiKeys, value: string) {
        (this.authentications as any)[AccountLinksControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create account link
     * @param request request
     */
    public createAccountLinkUsingPOST1 (request: AccountLinkCreateRequest) : Promise<{ response: http.IncomingMessage; body: AccountLink;  }> {
        const localVarPath = this.basePath + '/accountlinks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling createAccountLinkUsingPOST1.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "AccountLinkCreateRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get latest account link credential
     * @param id id
     */
    public getAccountLinkCredentialUsingGET (id: string) : Promise<{ response: http.IncomingMessage; body: AccountLink;  }> {
        const localVarPath = this.basePath + '/accountlinks/{id}/credential'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAccountLinkCredentialUsingGET.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update account link credential
     * @param id id
     * @param request request
     */
    public updateAccountLinkCredentialUsingPUT (id: string, request: AccountLinkCredentialUpdateRequest) : Promise<{ response: http.IncomingMessage; body: AccountLink;  }> {
        const localVarPath = this.basePath + '/accountlinks/{id}/credential'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateAccountLinkCredentialUsingPUT.');
        }

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling updateAccountLinkCredentialUsingPUT.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "AccountLinkCredentialUpdateRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AccountProviderControllerApiApiKeys {
    identityId,
    identityRole,
}

export class AccountProviderControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountProviderControllerApiApiKeys, value: string) {
        (this.authentications as any)[AccountProviderControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create or update provider account link
     * @param request request
     */
    public createOrUpdateAccountLinkUsingPUT (request: AccountLinkCreateOrUpdateRequest) : Promise<{ response: http.IncomingMessage; body: AccountLink;  }> {
        const localVarPath = this.basePath + '/accounts/yodlee/provider';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling createOrUpdateAccountLinkUsingPUT.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "AccountLinkCreateOrUpdateRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get provider account link
     * @param providerAccountId providerAccountId
     */
    public getAccountLinkByProviderUsingGET (providerAccountId: number) : Promise<{ response: http.IncomingMessage; body: AccountLink;  }> {
        const localVarPath = this.basePath + '/accounts/yodlee/provider/{providerAccountId}'
            .replace('{' + 'providerAccountId' + '}', encodeURIComponent(String(providerAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'providerAccountId' is not null or undefined
        if (providerAccountId === null || providerAccountId === undefined) {
            throw new Error('Required parameter providerAccountId was null or undefined when calling getAccountLinkByProviderUsingGET.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update provider account link
     * @param providerAccountId providerAccountId
     * @param request request
     */
    public updateAccountLinkByProviderUsingPUT (providerAccountId: number, request: AccountLinkUpdateRequest) : Promise<{ response: http.IncomingMessage; body: AccountLink;  }> {
        const localVarPath = this.basePath + '/accounts/yodlee/provider/{providerAccountId}'
            .replace('{' + 'providerAccountId' + '}', encodeURIComponent(String(providerAccountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'providerAccountId' is not null or undefined
        if (providerAccountId === null || providerAccountId === undefined) {
            throw new Error('Required parameter providerAccountId was null or undefined when calling updateAccountLinkByProviderUsingPUT.');
        }

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling updateAccountLinkByProviderUsingPUT.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "AccountLinkUpdateRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AccountUpdatedCountControllerApiApiKeys {
    identityId,
    identityRole,
}

export class AccountUpdatedCountControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountUpdatedCountControllerApiApiKeys, value: string) {
        (this.authentications as any)[AccountUpdatedCountControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get count of accounts updated within a time period
     * @param updatedWithinMinutes Account updated within this number of minutes
     */
    public getUpdatedCountUsingGET (updatedWithinMinutes?: number) : Promise<{ response: http.IncomingMessage; body: AccountUpdatedCountResponse;  }> {
        const localVarPath = this.basePath + '/accounts/updatedCount';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (updatedWithinMinutes !== undefined) {
            localVarQueryParameters['updatedWithinMinutes'] = ObjectSerializer.serialize(updatedWithinMinutes, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountUpdatedCountResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountUpdatedCountResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BasiqControllerApiApiKeys {
    identityId,
    identityRole,
}

export class BasiqControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BasiqControllerApiApiKeys, value: string) {
        (this.authentications as any)[BasiqControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get Basiq bearer token
     */
    public getTokenUsingGET () : Promise<{ response: http.IncomingMessage; body: BasiqBearerToken;  }> {
        const localVarPath = this.basePath + '/basiq/getToken';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BasiqBearerToken;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BasiqBearerToken");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CalendarControllerApiApiKeys {
    identityId,
    identityRole,
}

export class CalendarControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CalendarControllerApiApiKeys, value: string) {
        (this.authentications as any)[CalendarControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Archive all calendar items
     * @param guid guid
     */
    public archiveCalendarUsingDELETE (guid: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/calendar/archive';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'guid' is not null or undefined
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling archiveCalendarUsingDELETE.');
        }

        if (guid !== undefined) {
            localVarQueryParameters['guid'] = ObjectSerializer.serialize(guid, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Dismiss a transaction as a suggested calendar item
     * @param request request
     */
    public createCalendarDismissedUsingPOST (request: Array<CalendarDismissedCreateRequest>) : Promise<{ response: http.IncomingMessage; body: Array<CalendarDismissedResponse>;  }> {
        const localVarPath = this.basePath + '/calendar/dismissed';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling createCalendarDismissedUsingPOST.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "Array<CalendarDismissedCreateRequest>")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<CalendarDismissedResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CalendarDismissedResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a calendar item
     * @param calendarItemCreateRequest calendarItemCreateRequest
     */
    public createCalendarUsingPOST (calendarItemCreateRequest: CalendarItemCreateRequest) : Promise<{ response: http.IncomingMessage; body: CalendarItemResponse;  }> {
        const localVarPath = this.basePath + '/calendar/items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'calendarItemCreateRequest' is not null or undefined
        if (calendarItemCreateRequest === null || calendarItemCreateRequest === undefined) {
            throw new Error('Required parameter calendarItemCreateRequest was null or undefined when calling createCalendarUsingPOST.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(calendarItemCreateRequest, "CalendarItemCreateRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CalendarItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CalendarItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a calendar
     * @param calendarItemId calendarItemId
     */
    public deleteCalendarUsingDELETE (calendarItemId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/calendar/items/{calendarItemId}'
            .replace('{' + 'calendarItemId' + '}', encodeURIComponent(String(calendarItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'calendarItemId' is not null or undefined
        if (calendarItemId === null || calendarItemId === undefined) {
            throw new Error('Required parameter calendarItemId was null or undefined when calling deleteCalendarUsingDELETE.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all calendar items for a member
     * @param include include optional details
     * @param isSuggested suggested / non-suggested items
     * @param page Results page you want to retrieve (0..N)
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     */
    public getAllCalendarItemsUsingGET (include?: Array<'DETAILS'>, isSuggested?: boolean, page?: number, size?: number, sort?: Array<string>) : Promise<{ response: http.IncomingMessage; body: PageCalendarItemResponse;  }> {
        const localVarPath = this.basePath + '/calendar/items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<'DETAILS'>");
        }

        if (isSuggested !== undefined) {
            localVarQueryParameters['isSuggested'] = ObjectSerializer.serialize(isSuggested, "boolean");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PageCalendarItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageCalendarItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all calendar dismissed matchers
     * @param page Results page you want to retrieve (0..N)
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     */
    public getCalendarDismissedUsingGET (page?: number, size?: number, sort?: Array<string>) : Promise<{ response: http.IncomingMessage; body: PageCalendarDismissedResponse;  }> {
        const localVarPath = this.basePath + '/calendar/dismissed';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PageCalendarDismissedResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageCalendarDismissedResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get calendar events
     * @param fromDate calendar events from date (yyyy-MM-dd), inclusive
     * @param toDate calendar events to date (yyyy-MM-dd), inclusive
     * @param type type of calendar events, default to all types
     * @param effectiveDate calendar events effective date (yyyy-MM-dd), return same events response as at the effective date if set.
     * @param matched matched / non-matched events
     * @param isSuggested events from suggested / non-suggested items
     * @param page Results page you want to retrieve (0..N)
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     */
    public getCalendarEventsUsingGET (fromDate: string, toDate: string, type?: Array<'INCOME' | 'BILL'>, effectiveDate?: string, matched?: boolean, isSuggested?: boolean, page?: number, size?: number, sort?: Array<string>) : Promise<{ response: http.IncomingMessage; body: PageCalendarEvent;  }> {
        const localVarPath = this.basePath + '/calendar/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fromDate' is not null or undefined
        if (fromDate === null || fromDate === undefined) {
            throw new Error('Required parameter fromDate was null or undefined when calling getCalendarEventsUsingGET.');
        }

        // verify required parameter 'toDate' is not null or undefined
        if (toDate === null || toDate === undefined) {
            throw new Error('Required parameter toDate was null or undefined when calling getCalendarEventsUsingGET.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "Array<'INCOME' | 'BILL'>");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['fromDate'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['toDate'] = ObjectSerializer.serialize(toDate, "string");
        }

        if (effectiveDate !== undefined) {
            localVarQueryParameters['effectiveDate'] = ObjectSerializer.serialize(effectiveDate, "string");
        }

        if (matched !== undefined) {
            localVarQueryParameters['matched'] = ObjectSerializer.serialize(matched, "boolean");
        }

        if (isSuggested !== undefined) {
            localVarQueryParameters['isSuggested'] = ObjectSerializer.serialize(isSuggested, "boolean");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PageCalendarEvent;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageCalendarEvent");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get calendar item details
     * @param calendarItemId calendarItemId
     */
    public getCalendarItemByIdUsingGET (calendarItemId: string) : Promise<{ response: http.IncomingMessage; body: CalendarItemResponse;  }> {
        const localVarPath = this.basePath + '/calendar/items/{calendarItemId}'
            .replace('{' + 'calendarItemId' + '}', encodeURIComponent(String(calendarItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'calendarItemId' is not null or undefined
        if (calendarItemId === null || calendarItemId === undefined) {
            throw new Error('Required parameter calendarItemId was null or undefined when calling getCalendarItemByIdUsingGET.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CalendarItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CalendarItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get calendar matchers for a calendar
     * @param calendarItemId calendarItemId
     * @param page Results page you want to retrieve (0..N)
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     */
    public getCalendarMatchersByIdUsingGET (calendarItemId: string, page?: number, size?: number, sort?: Array<string>) : Promise<{ response: http.IncomingMessage; body: PageCalendarItemMatcherResponse;  }> {
        const localVarPath = this.basePath + '/calendar/items/{calendarItemId}/matchers'
            .replace('{' + 'calendarItemId' + '}', encodeURIComponent(String(calendarItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'calendarItemId' is not null or undefined
        if (calendarItemId === null || calendarItemId === undefined) {
            throw new Error('Required parameter calendarItemId was null or undefined when calling getCalendarMatchersByIdUsingGET.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PageCalendarItemMatcherResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageCalendarItemMatcherResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all calendar matchers
     * @param page Results page you want to retrieve (0..N)
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     */
    public getCalendarMatchersUsingGET (page?: number, size?: number, sort?: Array<string>) : Promise<{ response: http.IncomingMessage; body: PageCalendarItemMatcherResponse;  }> {
        const localVarPath = this.basePath + '/calendar/matchers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PageCalendarItemMatcherResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageCalendarItemMatcherResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a calendar item
     * @param calendarItemId calendarItemId
     * @param request request
     */
    public updateCalendarUsingPUT (calendarItemId: string, request: CalendarItemUpdateRequest) : Promise<{ response: http.IncomingMessage; body: CalendarItemResponse;  }> {
        const localVarPath = this.basePath + '/calendar/items/{calendarItemId}'
            .replace('{' + 'calendarItemId' + '}', encodeURIComponent(String(calendarItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'calendarItemId' is not null or undefined
        if (calendarItemId === null || calendarItemId === undefined) {
            throw new Error('Required parameter calendarItemId was null or undefined when calling updateCalendarUsingPUT.');
        }

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling updateCalendarUsingPUT.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "CalendarItemUpdateRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CalendarItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CalendarItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CategoryControllerApiApiKeys {
    identityId,
    identityRole,
}

export class CategoryControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CategoryControllerApiApiKeys, value: string) {
        (this.authentications as any)[CategoryControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get a category
     * @param id id
     */
    public readUsingGET (id: number) : Promise<{ response: http.IncomingMessage; body: Categories;  }> {
        const localVarPath = this.basePath + '/categories/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling readUsingGET.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Categories;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Categories");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get categories
     */
    public searchCategoryUsingGET () : Promise<{ response: http.IncomingMessage; body: Array<Categories>;  }> {
        const localVarPath = this.basePath + '/categories';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Categories>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Categories>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CategoryMatcherControllerApiApiKeys {
    identityId,
    identityRole,
}

export class CategoryMatcherControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CategoryMatcherControllerApiApiKeys, value: string) {
        (this.authentications as any)[CategoryMatcherControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Archive all category matchers of a member
     * @param guid guid
     */
    public archiveAllSpendingTargetsUsingDELETE (guid: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/categories/matchers/archive';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'guid' is not null or undefined
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling archiveAllSpendingTargetsUsingDELETE.');
        }

        if (guid !== undefined) {
            localVarQueryParameters['guid'] = ObjectSerializer.serialize(guid, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Post a list of new or existing category matchers
     * @param matchers matchers
     */
    public bulkPutCategoryMatcherUsingPOST (matchers: Array<CategoryMatcherRequest>) : Promise<{ response: http.IncomingMessage; body: Array<CategoryMatcherResponse>;  }> {
        const localVarPath = this.basePath + '/categories/matchers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'matchers' is not null or undefined
        if (matchers === null || matchers === undefined) {
            throw new Error('Required parameter matchers was null or undefined when calling bulkPutCategoryMatcherUsingPOST.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(matchers, "Array<CategoryMatcherRequest>")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<CategoryMatcherResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CategoryMatcherResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all category matchers
     * @param page Results page you want to retrieve (0..N)
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     */
    public getCategoryMatchersUsingGET (page?: number, size?: number, sort?: Array<string>) : Promise<{ response: http.IncomingMessage; body: PageCategoryMatcherResponse;  }> {
        const localVarPath = this.basePath + '/categories/matchers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PageCategoryMatcherResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageCategoryMatcherResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Put a new category matcher
     * @param matcher matcher
     */
    public putCategoryMatcherUsingPUT (matcher: CategoryMatcherRequest) : Promise<{ response: http.IncomingMessage; body: CategoryMatcherResponse;  }> {
        const localVarPath = this.basePath + '/categories/matchers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'matcher' is not null or undefined
        if (matcher === null || matcher === undefined) {
            throw new Error('Required parameter matcher was null or undefined when calling putCategoryMatcherUsingPUT.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(matcher, "CategoryMatcherRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CategoryMatcherResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CategoryMatcherResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ExternalCategoryControllerApiApiKeys {
    identityId,
    identityRole,
}

export class ExternalCategoryControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ExternalCategoryControllerApiApiKeys, value: string) {
        (this.authentications as any)[ExternalCategoryControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary A list single external category for the given external provider id, and id
     * @param providerId providerId
     * @param id id
     */
    public getUsingGET (providerId: number, id: string) : Promise<{ response: http.IncomingMessage; body: ExternalCategoryResponse;  }> {
        const localVarPath = this.basePath + '/categories/external/{providerId}/{id}'
            .replace('{' + 'providerId' + '}', encodeURIComponent(String(providerId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'providerId' is not null or undefined
        if (providerId === null || providerId === undefined) {
            throw new Error('Required parameter providerId was null or undefined when calling getUsingGET.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUsingGET.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExternalCategoryResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExternalCategoryResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of external categories for the given external provider id
     * @param providerId providerId
     */
    public listUsingGET (providerId: number) : Promise<{ response: http.IncomingMessage; body: Array<ExternalCategoryResponse>;  }> {
        const localVarPath = this.basePath + '/categories/external/{providerId}'
            .replace('{' + 'providerId' + '}', encodeURIComponent(String(providerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'providerId' is not null or undefined
        if (providerId === null || providerId === undefined) {
            throw new Error('Required parameter providerId was null or undefined when calling listUsingGET.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ExternalCategoryResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ExternalCategoryResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of external categories to category mappings for the given external provider id
     * @param providerId providerId
     */
    public mappingsUsingGET (providerId: number) : Promise<{ response: http.IncomingMessage; body: Array<CategoryMappingResponse>;  }> {
        const localVarPath = this.basePath + '/categories/external/{providerId}/mappings'
            .replace('{' + 'providerId' + '}', encodeURIComponent(String(providerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'providerId' is not null or undefined
        if (providerId === null || providerId === undefined) {
            throw new Error('Required parameter providerId was null or undefined when calling mappingsUsingGET.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<CategoryMappingResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CategoryMappingResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Bulk Store external categories
     * @param providerId providerId
     * @param categories categories
     */
    public saveUsingPOST (providerId: number, categories: Array<ExternalCategoryRequest>) : Promise<{ response: http.IncomingMessage; body: Array<ExternalCategoryResponse>;  }> {
        const localVarPath = this.basePath + '/categories/external/{providerId}'
            .replace('{' + 'providerId' + '}', encodeURIComponent(String(providerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'providerId' is not null or undefined
        if (providerId === null || providerId === undefined) {
            throw new Error('Required parameter providerId was null or undefined when calling saveUsingPOST.');
        }

        // verify required parameter 'categories' is not null or undefined
        if (categories === null || categories === undefined) {
            throw new Error('Required parameter categories was null or undefined when calling saveUsingPOST.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(categories, "Array<ExternalCategoryRequest>")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ExternalCategoryResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ExternalCategoryResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HealthControllerApiApiKeys {
    identityId,
    identityRole,
}

export class HealthControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HealthControllerApiApiKeys, value: string) {
        (this.authentications as any)[HealthControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary basic
     */
    public basicUsingGET () : Promise<{ response: http.IncomingMessage; body: BasicHealth;  }> {
        const localVarPath = this.basePath + '/health';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BasicHealth;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BasicHealth");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SpendingControllerApiApiKeys {
    identityId,
    identityRole,
}

export class SpendingControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SpendingControllerApiApiKeys, value: string) {
        (this.authentications as any)[SpendingControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get spending by category daily for a month
     * @param year year
     * @param month month
     * @param accountId 
     * @param categoryId 
     * @param calendarItemId 
     * @param status 
     * @param tagId 
     * @param isCalendarEvent 
     * @param search 
     * @param isNotDismissed When true, leaves out transactions that have been dismissed as suggested calendar events
     * @param fromDate 
     * @param toDate 
     * @param createdOnOrAfter Transaction Created On or After this date an time in ISO DateTime Format (like 2018-04-30T00:21:20.197Z)
     * @param amountGt 
     * @param amountGte 
     * @param amountLt 
     * @param amountLte 
     */
    public getSpendingUsingGET (year: number, month: number, accountId?: Array<string>, categoryId?: Array<number>, calendarItemId?: Array<string>, status?: Array<'POSTED' | 'PENDING' | 'SCHEDULED' | 'DELETED'>, tagId?: Array<string>, isCalendarEvent?: boolean, search?: string, isNotDismissed?: boolean, fromDate?: string, toDate?: string, createdOnOrAfter?: Date, amountGt?: number, amountGte?: number, amountLt?: number, amountLte?: number) : Promise<{ response: http.IncomingMessage; body: SpendingDailyResponse;  }> {
        const localVarPath = this.basePath + '/transactions/spending/{year}/{month}'
            .replace('{' + 'year' + '}', encodeURIComponent(String(year)))
            .replace('{' + 'month' + '}', encodeURIComponent(String(month)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'year' is not null or undefined
        if (year === null || year === undefined) {
            throw new Error('Required parameter year was null or undefined when calling getSpendingUsingGET.');
        }

        // verify required parameter 'month' is not null or undefined
        if (month === null || month === undefined) {
            throw new Error('Required parameter month was null or undefined when calling getSpendingUsingGET.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "Array<string>");
        }

        if (categoryId !== undefined) {
            localVarQueryParameters['categoryId'] = ObjectSerializer.serialize(categoryId, "Array<number>");
        }

        if (calendarItemId !== undefined) {
            localVarQueryParameters['calendarItemId'] = ObjectSerializer.serialize(calendarItemId, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'POSTED' | 'PENDING' | 'SCHEDULED' | 'DELETED'>");
        }

        if (tagId !== undefined) {
            localVarQueryParameters['tagId'] = ObjectSerializer.serialize(tagId, "Array<string>");
        }

        if (isCalendarEvent !== undefined) {
            localVarQueryParameters['isCalendarEvent'] = ObjectSerializer.serialize(isCalendarEvent, "boolean");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (isNotDismissed !== undefined) {
            localVarQueryParameters['isNotDismissed'] = ObjectSerializer.serialize(isNotDismissed, "boolean");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['fromDate'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['toDate'] = ObjectSerializer.serialize(toDate, "string");
        }

        if (createdOnOrAfter !== undefined) {
            localVarQueryParameters['createdOnOrAfter'] = ObjectSerializer.serialize(createdOnOrAfter, "Date");
        }

        if (amountGt !== undefined) {
            localVarQueryParameters['amountGt'] = ObjectSerializer.serialize(amountGt, "number");
        }

        if (amountGte !== undefined) {
            localVarQueryParameters['amountGte'] = ObjectSerializer.serialize(amountGte, "number");
        }

        if (amountLt !== undefined) {
            localVarQueryParameters['amountLt'] = ObjectSerializer.serialize(amountLt, "number");
        }

        if (amountLte !== undefined) {
            localVarQueryParameters['amountLte'] = ObjectSerializer.serialize(amountLte, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SpendingDailyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SpendingDailyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get spending by category monthly for a year
     * @param year year
     * @param accountId 
     * @param categoryId 
     * @param calendarItemId 
     * @param status 
     * @param tagId 
     * @param isCalendarEvent 
     * @param search 
     * @param isNotDismissed When true, leaves out transactions that have been dismissed as suggested calendar events
     * @param fromDate 
     * @param toDate 
     * @param createdOnOrAfter Transaction Created On or After this date an time in ISO DateTime Format (like 2018-04-30T00:21:20.197Z)
     * @param amountGt 
     * @param amountGte 
     * @param amountLt 
     * @param amountLte 
     */
    public getSpendingUsingGET1 (year: number, accountId?: Array<string>, categoryId?: Array<number>, calendarItemId?: Array<string>, status?: Array<'POSTED' | 'PENDING' | 'SCHEDULED' | 'DELETED'>, tagId?: Array<string>, isCalendarEvent?: boolean, search?: string, isNotDismissed?: boolean, fromDate?: string, toDate?: string, createdOnOrAfter?: Date, amountGt?: number, amountGte?: number, amountLt?: number, amountLte?: number) : Promise<{ response: http.IncomingMessage; body: SpendingMonthlyResponse;  }> {
        const localVarPath = this.basePath + '/transactions/spending/{year}'
            .replace('{' + 'year' + '}', encodeURIComponent(String(year)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'year' is not null or undefined
        if (year === null || year === undefined) {
            throw new Error('Required parameter year was null or undefined when calling getSpendingUsingGET1.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "Array<string>");
        }

        if (categoryId !== undefined) {
            localVarQueryParameters['categoryId'] = ObjectSerializer.serialize(categoryId, "Array<number>");
        }

        if (calendarItemId !== undefined) {
            localVarQueryParameters['calendarItemId'] = ObjectSerializer.serialize(calendarItemId, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'POSTED' | 'PENDING' | 'SCHEDULED' | 'DELETED'>");
        }

        if (tagId !== undefined) {
            localVarQueryParameters['tagId'] = ObjectSerializer.serialize(tagId, "Array<string>");
        }

        if (isCalendarEvent !== undefined) {
            localVarQueryParameters['isCalendarEvent'] = ObjectSerializer.serialize(isCalendarEvent, "boolean");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (isNotDismissed !== undefined) {
            localVarQueryParameters['isNotDismissed'] = ObjectSerializer.serialize(isNotDismissed, "boolean");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['fromDate'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['toDate'] = ObjectSerializer.serialize(toDate, "string");
        }

        if (createdOnOrAfter !== undefined) {
            localVarQueryParameters['createdOnOrAfter'] = ObjectSerializer.serialize(createdOnOrAfter, "Date");
        }

        if (amountGt !== undefined) {
            localVarQueryParameters['amountGt'] = ObjectSerializer.serialize(amountGt, "number");
        }

        if (amountGte !== undefined) {
            localVarQueryParameters['amountGte'] = ObjectSerializer.serialize(amountGte, "number");
        }

        if (amountLt !== undefined) {
            localVarQueryParameters['amountLt'] = ObjectSerializer.serialize(amountLt, "number");
        }

        if (amountLte !== undefined) {
            localVarQueryParameters['amountLte'] = ObjectSerializer.serialize(amountLte, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SpendingMonthlyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SpendingMonthlyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get spending by category monthly for a year
     * @param accountId 
     * @param categoryId 
     * @param calendarItemId 
     * @param status 
     * @param tagId 
     * @param isCalendarEvent 
     * @param search 
     * @param isNotDismissed When true, leaves out transactions that have been dismissed as suggested calendar events
     * @param fromDate 
     * @param toDate 
     * @param createdOnOrAfter Transaction Created On or After this date an time in ISO DateTime Format (like 2018-04-30T00:21:20.197Z)
     * @param amountGt 
     * @param amountGte 
     * @param amountLt 
     * @param amountLte 
     */
    public getSpendingUsingGET2 (accountId?: Array<string>, categoryId?: Array<number>, calendarItemId?: Array<string>, status?: Array<'POSTED' | 'PENDING' | 'SCHEDULED' | 'DELETED'>, tagId?: Array<string>, isCalendarEvent?: boolean, search?: string, isNotDismissed?: boolean, fromDate?: string, toDate?: string, createdOnOrAfter?: Date, amountGt?: number, amountGte?: number, amountLt?: number, amountLte?: number) : Promise<{ response: http.IncomingMessage; body: SpendingResponse;  }> {
        const localVarPath = this.basePath + '/transactions/spending';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "Array<string>");
        }

        if (categoryId !== undefined) {
            localVarQueryParameters['categoryId'] = ObjectSerializer.serialize(categoryId, "Array<number>");
        }

        if (calendarItemId !== undefined) {
            localVarQueryParameters['calendarItemId'] = ObjectSerializer.serialize(calendarItemId, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'POSTED' | 'PENDING' | 'SCHEDULED' | 'DELETED'>");
        }

        if (tagId !== undefined) {
            localVarQueryParameters['tagId'] = ObjectSerializer.serialize(tagId, "Array<string>");
        }

        if (isCalendarEvent !== undefined) {
            localVarQueryParameters['isCalendarEvent'] = ObjectSerializer.serialize(isCalendarEvent, "boolean");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (isNotDismissed !== undefined) {
            localVarQueryParameters['isNotDismissed'] = ObjectSerializer.serialize(isNotDismissed, "boolean");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['fromDate'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['toDate'] = ObjectSerializer.serialize(toDate, "string");
        }

        if (createdOnOrAfter !== undefined) {
            localVarQueryParameters['createdOnOrAfter'] = ObjectSerializer.serialize(createdOnOrAfter, "Date");
        }

        if (amountGt !== undefined) {
            localVarQueryParameters['amountGt'] = ObjectSerializer.serialize(amountGt, "number");
        }

        if (amountGte !== undefined) {
            localVarQueryParameters['amountGte'] = ObjectSerializer.serialize(amountGte, "number");
        }

        if (amountLt !== undefined) {
            localVarQueryParameters['amountLt'] = ObjectSerializer.serialize(amountLt, "number");
        }

        if (amountLte !== undefined) {
            localVarQueryParameters['amountLte'] = ObjectSerializer.serialize(amountLte, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SpendingResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SpendingResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SpendingOverrideControllerApiApiKeys {
    identityId,
    identityRole,
}

export class SpendingOverrideControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SpendingOverrideControllerApiApiKeys, value: string) {
        (this.authentications as any)[SpendingOverrideControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create or update spending overrides for a member
     * @param spendingOverrideBatchCreateUpdates spendingOverrideBatchCreateUpdates
     */
    public batchCreateUpdateSpendingOverridesUsingPUT (spendingOverrideBatchCreateUpdates: SpendingOverrideBatchCreateUpdate) : Promise<{ response: http.IncomingMessage; body: Array<SpendingOverrideResponse>;  }> {
        const localVarPath = this.basePath + '/spendingoverrides';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'spendingOverrideBatchCreateUpdates' is not null or undefined
        if (spendingOverrideBatchCreateUpdates === null || spendingOverrideBatchCreateUpdates === undefined) {
            throw new Error('Required parameter spendingOverrideBatchCreateUpdates was null or undefined when calling batchCreateUpdateSpendingOverridesUsingPUT.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(spendingOverrideBatchCreateUpdates, "SpendingOverrideBatchCreateUpdate")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<SpendingOverrideResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SpendingOverrideResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Find spending overrides for a member
     * @param fromEndingDate Pay cycles ending on or after this date
     * @param toEndingDate Pay cycles ending on or before this date
     * @param payCycleLength Pay cycles length (WEEK/FORTNIGHT/MONTH)
     * @param page Results page you want to retrieve (0..N)
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     */
    public findSpendingOverridesUsingGET (fromEndingDate: string, toEndingDate: string, payCycleLength: 'WEEK' | 'FORTNIGHT' | 'MONTH', page?: number, size?: number, sort?: Array<string>) : Promise<{ response: http.IncomingMessage; body: PageSpendingOverrideResponse;  }> {
        const localVarPath = this.basePath + '/spendingoverrides';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fromEndingDate' is not null or undefined
        if (fromEndingDate === null || fromEndingDate === undefined) {
            throw new Error('Required parameter fromEndingDate was null or undefined when calling findSpendingOverridesUsingGET.');
        }

        // verify required parameter 'toEndingDate' is not null or undefined
        if (toEndingDate === null || toEndingDate === undefined) {
            throw new Error('Required parameter toEndingDate was null or undefined when calling findSpendingOverridesUsingGET.');
        }

        // verify required parameter 'payCycleLength' is not null or undefined
        if (payCycleLength === null || payCycleLength === undefined) {
            throw new Error('Required parameter payCycleLength was null or undefined when calling findSpendingOverridesUsingGET.');
        }

        if (fromEndingDate !== undefined) {
            localVarQueryParameters['fromEndingDate'] = ObjectSerializer.serialize(fromEndingDate, "string");
        }

        if (toEndingDate !== undefined) {
            localVarQueryParameters['toEndingDate'] = ObjectSerializer.serialize(toEndingDate, "string");
        }

        if (payCycleLength !== undefined) {
            localVarQueryParameters['payCycleLength'] = ObjectSerializer.serialize(payCycleLength, "'WEEK' | 'FORTNIGHT' | 'MONTH'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PageSpendingOverrideResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageSpendingOverrideResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get digested spending overrides for a member over a number of pay cycles
     * @param fromEndingDate Pay cycles ending on or after this date
     * @param toEndingDate Pay cycles ending on or before this date
     * @param payCycleLength Pay cycles length (WEEK/FORTNIGHT/MONTH)
     */
    public getSpendingOverrideDigestUsingGET (fromEndingDate: string, toEndingDate: string, payCycleLength: 'WEEK' | 'FORTNIGHT' | 'MONTH') : Promise<{ response: http.IncomingMessage; body: { [key: string]: { [key: string]: number; }; };  }> {
        const localVarPath = this.basePath + '/spendingoverrides/digests';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fromEndingDate' is not null or undefined
        if (fromEndingDate === null || fromEndingDate === undefined) {
            throw new Error('Required parameter fromEndingDate was null or undefined when calling getSpendingOverrideDigestUsingGET.');
        }

        // verify required parameter 'toEndingDate' is not null or undefined
        if (toEndingDate === null || toEndingDate === undefined) {
            throw new Error('Required parameter toEndingDate was null or undefined when calling getSpendingOverrideDigestUsingGET.');
        }

        // verify required parameter 'payCycleLength' is not null or undefined
        if (payCycleLength === null || payCycleLength === undefined) {
            throw new Error('Required parameter payCycleLength was null or undefined when calling getSpendingOverrideDigestUsingGET.');
        }

        if (fromEndingDate !== undefined) {
            localVarQueryParameters['fromEndingDate'] = ObjectSerializer.serialize(fromEndingDate, "string");
        }

        if (toEndingDate !== undefined) {
            localVarQueryParameters['toEndingDate'] = ObjectSerializer.serialize(toEndingDate, "string");
        }

        if (payCycleLength !== undefined) {
            localVarQueryParameters['payCycleLength'] = ObjectSerializer.serialize(payCycleLength, "'WEEK' | 'FORTNIGHT' | 'MONTH'");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: { [key: string]: { [key: string]: number; }; };  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "{ [key: string]: { [key: string]: number; }; }");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Read spending override by ID for a member
     * @param spendingOverrideId spendingOverrideId
     */
    public readSpendingOverrideUsingGET (spendingOverrideId: string) : Promise<{ response: http.IncomingMessage; body: SpendingOverrideResponse;  }> {
        const localVarPath = this.basePath + '/spendingoverrides/{spendingOverrideId}'
            .replace('{' + 'spendingOverrideId' + '}', encodeURIComponent(String(spendingOverrideId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'spendingOverrideId' is not null or undefined
        if (spendingOverrideId === null || spendingOverrideId === undefined) {
            throw new Error('Required parameter spendingOverrideId was null or undefined when calling readSpendingOverrideUsingGET.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SpendingOverrideResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SpendingOverrideResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SpendingTargetControllerApiApiKeys {
    identityId,
    identityRole,
}

export class SpendingTargetControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SpendingTargetControllerApiApiKeys, value: string) {
        (this.authentications as any)[SpendingTargetControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Archive all spending targets of a member
     * @param guid guid
     */
    public archiveAllSpendingTargetsUsingDELETE1 (guid: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/spendingtargets/archive';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'guid' is not null or undefined
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling archiveAllSpendingTargetsUsingDELETE1.');
        }

        if (guid !== undefined) {
            localVarQueryParameters['guid'] = ObjectSerializer.serialize(guid, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a spending target for a member
     * @param spendingTargetCreateRequest spendingTargetCreateRequest
     */
    public createSpendingTargetUsingPOST (spendingTargetCreateRequest: SpendingTargetCreateRequest) : Promise<{ response: http.IncomingMessage; body: SpendingTargetResponse;  }> {
        const localVarPath = this.basePath + '/spendingtargets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'spendingTargetCreateRequest' is not null or undefined
        if (spendingTargetCreateRequest === null || spendingTargetCreateRequest === undefined) {
            throw new Error('Required parameter spendingTargetCreateRequest was null or undefined when calling createSpendingTargetUsingPOST.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(spendingTargetCreateRequest, "SpendingTargetCreateRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SpendingTargetResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SpendingTargetResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a spending target for a member
     * @param spendingTargetId spendingTargetId
     */
    public deleteSpendingTargetUsingDELETE (spendingTargetId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/spendingtargets/{spendingTargetId}'
            .replace('{' + 'spendingTargetId' + '}', encodeURIComponent(String(spendingTargetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'spendingTargetId' is not null or undefined
        if (spendingTargetId === null || spendingTargetId === undefined) {
            throw new Error('Required parameter spendingTargetId was null or undefined when calling deleteSpendingTargetUsingDELETE.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all spending targets for a member
     */
    public getSpendingTargetsUsingGET () : Promise<{ response: http.IncomingMessage; body: PageSpendingTargetResponse;  }> {
        const localVarPath = this.basePath + '/spendingtargets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PageSpendingTargetResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageSpendingTargetResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a spending target for a member
     * @param spendingTargetId spendingTargetId
     * @param spendingTargetUpdateRequest spendingTargetUpdateRequest
     */
    public updateSpendingTargetUsingPUT (spendingTargetId: string, spendingTargetUpdateRequest: SpendingTargetUpdateRequest) : Promise<{ response: http.IncomingMessage; body: SpendingTargetResponse;  }> {
        const localVarPath = this.basePath + '/spendingtargets/{spendingTargetId}'
            .replace('{' + 'spendingTargetId' + '}', encodeURIComponent(String(spendingTargetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'spendingTargetId' is not null or undefined
        if (spendingTargetId === null || spendingTargetId === undefined) {
            throw new Error('Required parameter spendingTargetId was null or undefined when calling updateSpendingTargetUsingPUT.');
        }

        // verify required parameter 'spendingTargetUpdateRequest' is not null or undefined
        if (spendingTargetUpdateRequest === null || spendingTargetUpdateRequest === undefined) {
            throw new Error('Required parameter spendingTargetUpdateRequest was null or undefined when calling updateSpendingTargetUsingPUT.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(spendingTargetUpdateRequest, "SpendingTargetUpdateRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SpendingTargetResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SpendingTargetResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TagControllerApiApiKeys {
    identityId,
    identityRole,
}

export class TagControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TagControllerApiApiKeys, value: string) {
        (this.authentications as any)[TagControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Archive all tags of a member
     * @param guid guid
     */
    public archiveAllTagsUsingDELETE (guid: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tags/archive';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'guid' is not null or undefined
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling archiveAllTagsUsingDELETE.');
        }

        if (guid !== undefined) {
            localVarQueryParameters['guid'] = ObjectSerializer.serialize(guid, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new tag
     * @param tagRequest tagRequest
     */
    public createUsingPOST (tagRequest: TagRequest) : Promise<{ response: http.IncomingMessage; body: TagResponse;  }> {
        const localVarPath = this.basePath + '/tags';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tagRequest' is not null or undefined
        if (tagRequest === null || tagRequest === undefined) {
            throw new Error('Required parameter tagRequest was null or undefined when calling createUsingPOST.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(tagRequest, "TagRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TagResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TagResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a tag
     * @param id id
     */
    public deleteCalendarUsingDELETE1 (id: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tags/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCalendarUsingDELETE1.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a tag
     * @param id id
     */
    public getUsingGET1 (id: string) : Promise<{ response: http.IncomingMessage; body: TagResponse;  }> {
        const localVarPath = this.basePath + '/tags/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUsingGET1.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TagResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TagResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all tags
     * @param page Results page you want to retrieve (0..N)
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     */
    public getUsingGET2 (page?: number, size?: number, sort?: Array<string>) : Promise<{ response: http.IncomingMessage; body: PageTagResponse;  }> {
        const localVarPath = this.basePath + '/tags';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PageTagResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PageTagResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a tag
     * @param id id
     * @param tagRequest tagRequest
     */
    public updateUsingPUT (id: string, tagRequest: TagRequest) : Promise<{ response: http.IncomingMessage; body: TagResponse;  }> {
        const localVarPath = this.basePath + '/tags/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUsingPUT.');
        }

        // verify required parameter 'tagRequest' is not null or undefined
        if (tagRequest === null || tagRequest === undefined) {
            throw new Error('Required parameter tagRequest was null or undefined when calling updateUsingPUT.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(tagRequest, "TagRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TagResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TagResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionClusterControllerApiApiKeys {
    identityId,
    identityRole,
}

export class TransactionClusterControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionClusterControllerApiApiKeys, value: string) {
        (this.authentications as any)[TransactionClusterControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Archive all transaction clusters of a member
     * @param guid guid
     */
    public archiveAllTransactionClustersUsingDELETE (guid: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/transactionclusters/archive';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'guid' is not null or undefined
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling archiveAllTransactionClustersUsingDELETE.');
        }

        if (guid !== undefined) {
            localVarQueryParameters['guid'] = ObjectSerializer.serialize(guid, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new transaction cluster
     * @param cluster cluster
     */
    public createTransactionClusterUsingPOST (cluster: TransactionClusterRequest) : Promise<{ response: http.IncomingMessage; body: TransactionClusterResponse;  }> {
        const localVarPath = this.basePath + '/transactionclusters';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cluster' is not null or undefined
        if (cluster === null || cluster === undefined) {
            throw new Error('Required parameter cluster was null or undefined when calling createTransactionClusterUsingPOST.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(cluster, "TransactionClusterRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionClusterResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionClusterResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a transaction cluster
     * @param id id
     */
    public deleteTransactionClusterUsingDELETE (id: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/transactionclusters/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTransactionClusterUsingDELETE.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get best scored transaction cluster of a member
     */
    public getBestTransactionClusterUsingGET () : Promise<{ response: http.IncomingMessage; body: TransactionClusterResponse;  }> {
        const localVarPath = this.basePath + '/transactionclusters/best';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionClusterResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionClusterResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all transaction clusters for a member
     * @param include 
     * @param type 
     */
    public getClustersForMemberUsingGET (include?: Array<'DETAILS'>, type?: 'EXPENSE' | 'INCOME') : Promise<{ response: http.IncomingMessage; body: Array<TransactionClusterResponse>;  }> {
        const localVarPath = this.basePath + '/transactionclusters';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<'DETAILS'>");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'EXPENSE' | 'INCOME'");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TransactionClusterResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionClusterResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update the score of a cluster and the transactions that are contained in it
     * @param clusterId clusterId
     * @param clusterUpdateRequest clusterUpdateRequest
     */
    public updateTransactionClusterUsingPUT (clusterId: string, clusterUpdateRequest: TransactionClusterUpdateRequest) : Promise<{ response: http.IncomingMessage; body: TransactionClusterResponse;  }> {
        const localVarPath = this.basePath + '/transactionclusters/{clusterId}'
            .replace('{' + 'clusterId' + '}', encodeURIComponent(String(clusterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clusterId' is not null or undefined
        if (clusterId === null || clusterId === undefined) {
            throw new Error('Required parameter clusterId was null or undefined when calling updateTransactionClusterUsingPUT.');
        }

        // verify required parameter 'clusterUpdateRequest' is not null or undefined
        if (clusterUpdateRequest === null || clusterUpdateRequest === undefined) {
            throw new Error('Required parameter clusterUpdateRequest was null or undefined when calling updateTransactionClusterUsingPUT.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(clusterUpdateRequest, "TransactionClusterUpdateRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionClusterResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionClusterResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionControllerApiApiKeys {
    identityId,
    identityRole,
}

export class TransactionControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionControllerApiApiKeys, value: string) {
        (this.authentications as any)[TransactionControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Archive all transactions of a member
     * @param guid guid
     */
    public archiveAllTransactionsUsingDELETE (guid: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/transactions/archive';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'guid' is not null or undefined
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling archiveAllTransactionsUsingDELETE.');
        }

        if (guid !== undefined) {
            localVarQueryParameters['guid'] = ObjectSerializer.serialize(guid, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Bulk Store Transactions
     * @param transactions transactions
     */
    public bulkSaveUsingPOST (transactions: Array<TransactionRequest>) : Promise<{ response: http.IncomingMessage; body: Array<TransactionResponse>;  }> {
        const localVarPath = this.basePath + '/transactions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transactions' is not null or undefined
        if (transactions === null || transactions === undefined) {
            throw new Error('Required parameter transactions was null or undefined when calling bulkSaveUsingPOST.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(transactions, "Array<TransactionRequest>")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TransactionResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Bulk Update Transactions
     * @param updateRequests updateRequests
     * @param overwriteCategory overwriteCategory
     * @param createCalendarMatchers createCalendarMatchers
     */
    public bulkUpdateUsingPUT (updateRequests: Array<TransactionUpdateRequest>, overwriteCategory?: boolean, createCalendarMatchers?: boolean) : Promise<{ response: http.IncomingMessage; body: Array<TransactionResponse>;  }> {
        const localVarPath = this.basePath + '/transactions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'updateRequests' is not null or undefined
        if (updateRequests === null || updateRequests === undefined) {
            throw new Error('Required parameter updateRequests was null or undefined when calling bulkUpdateUsingPUT.');
        }

        if (overwriteCategory !== undefined) {
            localVarQueryParameters['overwriteCategory'] = ObjectSerializer.serialize(overwriteCategory, "boolean");
        }

        if (createCalendarMatchers !== undefined) {
            localVarQueryParameters['createCalendarMatchers'] = ObjectSerializer.serialize(createCalendarMatchers, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateRequests, "Array<TransactionUpdateRequest>")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TransactionResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TransactionResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete Transactions for a given AccountId
     * @param id id
     */
    public deleteByAccountIdUsingDELETE (id: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/transactions/account/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteByAccountIdUsingDELETE.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Transactions count
     * @param accountId 
     * @param categoryId 
     * @param calendarItemId 
     * @param status 
     * @param tagId 
     * @param isCalendarEvent 
     * @param search 
     * @param isNotDismissed When true, leaves out transactions that have been dismissed as suggested calendar events
     * @param fromDate 
     * @param toDate 
     * @param createdOnOrAfter Transaction Created On or After this date an time in ISO DateTime Format (like 2018-04-30T00:21:20.197Z)
     * @param amountGt 
     * @param amountGte 
     * @param amountLt 
     * @param amountLte 
     * @param filter filter
     */
    public getTransactionCountUsingGET (accountId?: Array<string>, categoryId?: Array<number>, calendarItemId?: Array<string>, status?: Array<'POSTED' | 'PENDING' | 'SCHEDULED' | 'DELETED'>, tagId?: Array<string>, isCalendarEvent?: boolean, search?: string, isNotDismissed?: boolean, fromDate?: string, toDate?: string, createdOnOrAfter?: Date, amountGt?: number, amountGte?: number, amountLt?: number, amountLte?: number, filter?: Array<'SORTED' | 'UNSORTED' | 'TRANSFERS' | 'PENDING'>) : Promise<{ response: http.IncomingMessage; body: TransactionCountResponse;  }> {
        const localVarPath = this.basePath + '/transactions/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "Array<string>");
        }

        if (categoryId !== undefined) {
            localVarQueryParameters['categoryId'] = ObjectSerializer.serialize(categoryId, "Array<number>");
        }

        if (calendarItemId !== undefined) {
            localVarQueryParameters['calendarItemId'] = ObjectSerializer.serialize(calendarItemId, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'POSTED' | 'PENDING' | 'SCHEDULED' | 'DELETED'>");
        }

        if (tagId !== undefined) {
            localVarQueryParameters['tagId'] = ObjectSerializer.serialize(tagId, "Array<string>");
        }

        if (isCalendarEvent !== undefined) {
            localVarQueryParameters['isCalendarEvent'] = ObjectSerializer.serialize(isCalendarEvent, "boolean");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (isNotDismissed !== undefined) {
            localVarQueryParameters['isNotDismissed'] = ObjectSerializer.serialize(isNotDismissed, "boolean");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['fromDate'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['toDate'] = ObjectSerializer.serialize(toDate, "string");
        }

        if (createdOnOrAfter !== undefined) {
            localVarQueryParameters['createdOnOrAfter'] = ObjectSerializer.serialize(createdOnOrAfter, "Date");
        }

        if (amountGt !== undefined) {
            localVarQueryParameters['amountGt'] = ObjectSerializer.serialize(amountGt, "number");
        }

        if (amountGte !== undefined) {
            localVarQueryParameters['amountGte'] = ObjectSerializer.serialize(amountGte, "number");
        }

        if (amountLt !== undefined) {
            localVarQueryParameters['amountLt'] = ObjectSerializer.serialize(amountLt, "number");
        }

        if (amountLte !== undefined) {
            localVarQueryParameters['amountLte'] = ObjectSerializer.serialize(amountLte, "number");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "Array<'SORTED' | 'UNSORTED' | 'TRANSFERS' | 'PENDING'>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionCountResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionCountResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single Transaction
     * @param id id
     */
    public getTransactionUsingGET (id: string) : Promise<{ response: http.IncomingMessage; body: TransactionResponse;  }> {
        const localVarPath = this.basePath + '/transactions/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransactionUsingGET.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all Transactions for a member
     * @param accountId 
     * @param categoryId 
     * @param calendarItemId 
     * @param status 
     * @param tagId 
     * @param isCalendarEvent 
     * @param search 
     * @param isNotDismissed When true, leaves out transactions that have been dismissed as suggested calendar events
     * @param fromDate 
     * @param toDate 
     * @param createdOnOrAfter Transaction Created On or After this date an time in ISO DateTime Format (like 2018-04-30T00:21:20.197Z)
     * @param amountGt 
     * @param amountGte 
     * @param amountLt 
     * @param amountLte 
     * @param filter filter
     * @param page Results page you want to retrieve (0..N)
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     */
    public getTransactionsUsingGET (accountId?: Array<string>, categoryId?: Array<number>, calendarItemId?: Array<string>, status?: Array<'POSTED' | 'PENDING' | 'SCHEDULED' | 'DELETED'>, tagId?: Array<string>, isCalendarEvent?: boolean, search?: string, isNotDismissed?: boolean, fromDate?: string, toDate?: string, createdOnOrAfter?: Date, amountGt?: number, amountGte?: number, amountLt?: number, amountLte?: number, filter?: Array<'SORTED' | 'UNSORTED' | 'TRANSFERS' | 'PENDING'>, page?: number, size?: number, sort?: Array<string>) : Promise<{ response: http.IncomingMessage; body: TransactionPage;  }> {
        const localVarPath = this.basePath + '/transactions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "Array<string>");
        }

        if (categoryId !== undefined) {
            localVarQueryParameters['categoryId'] = ObjectSerializer.serialize(categoryId, "Array<number>");
        }

        if (calendarItemId !== undefined) {
            localVarQueryParameters['calendarItemId'] = ObjectSerializer.serialize(calendarItemId, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'POSTED' | 'PENDING' | 'SCHEDULED' | 'DELETED'>");
        }

        if (tagId !== undefined) {
            localVarQueryParameters['tagId'] = ObjectSerializer.serialize(tagId, "Array<string>");
        }

        if (isCalendarEvent !== undefined) {
            localVarQueryParameters['isCalendarEvent'] = ObjectSerializer.serialize(isCalendarEvent, "boolean");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (isNotDismissed !== undefined) {
            localVarQueryParameters['isNotDismissed'] = ObjectSerializer.serialize(isNotDismissed, "boolean");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['fromDate'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['toDate'] = ObjectSerializer.serialize(toDate, "string");
        }

        if (createdOnOrAfter !== undefined) {
            localVarQueryParameters['createdOnOrAfter'] = ObjectSerializer.serialize(createdOnOrAfter, "Date");
        }

        if (amountGt !== undefined) {
            localVarQueryParameters['amountGt'] = ObjectSerializer.serialize(amountGt, "number");
        }

        if (amountGte !== undefined) {
            localVarQueryParameters['amountGte'] = ObjectSerializer.serialize(amountGte, "number");
        }

        if (amountLt !== undefined) {
            localVarQueryParameters['amountLt'] = ObjectSerializer.serialize(amountLt, "number");
        }

        if (amountLte !== undefined) {
            localVarQueryParameters['amountLte'] = ObjectSerializer.serialize(amountLte, "number");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "Array<'SORTED' | 'UNSORTED' | 'TRANSFERS' | 'PENDING'>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionPage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionPage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unmark transaction as calendar event
     * @param transactionId transactionId
     */
    public unmarkTransactionAsCalendarEventUsingDELETE (transactionId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/transactions/{transactionId}/calendarevent'
            .replace('{' + 'transactionId' + '}', encodeURIComponent(String(transactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling unmarkTransactionAsCalendarEventUsingDELETE.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a Transaction
     * @param id id
     * @param request request
     */
    public updateUsingPUT1 (id: string, request: TransactionUpdateRequest) : Promise<{ response: http.IncomingMessage; body: TransactionResponse;  }> {
        const localVarPath = this.basePath + '/transactions/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUsingPUT1.');
        }

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling updateUsingPUT1.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "TransactionUpdateRequest")
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum YodleeControllerApiApiKeys {
    identityId,
    identityRole,
}

export class YodleeControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'identityId': new ApiKeyAuth('header', 'X-Identity-Id'),
        'identityRole': new ApiKeyAuth('header', 'X-Identity-Role'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: YodleeControllerApiApiKeys, value: string) {
        (this.authentications as any)[YodleeControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete Yodlee User
     */
    public deleteUserUsingDELETE () : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/yodlee/user';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a Members Account Summary for each account they have at the given providerAccountId
     * @param providerAccountId providerAccountId
     */
    public getAccountsUsingGET (providerAccountId: number) : Promise<{ response: http.IncomingMessage; body: GetAccountsResponse;  }> {
        const localVarPath = this.basePath + '/yodlee/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'providerAccountId' is not null or undefined
        if (providerAccountId === null || providerAccountId === undefined) {
            throw new Error('Required parameter providerAccountId was null or undefined when calling getAccountsUsingGET.');
        }

        if (providerAccountId !== undefined) {
            localVarQueryParameters['providerAccountId'] = ObjectSerializer.serialize(providerAccountId, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetAccountsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetAccountsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get CobrandSession
     */
    public getCobrandSessionUsingGET () : Promise<{ response: http.IncomingMessage; body: YodleeCobrandSession;  }> {
        const localVarPath = this.basePath + '/yodlee/cobrandSession';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: YodleeCobrandSession;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "YodleeCobrandSession");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a fastlink token
     * @param bankId bankId
     */
    public getFastlinkSessionUsingGET (bankId: number) : Promise<{ response: http.IncomingMessage; body: FastlinkSession;  }> {
        const localVarPath = this.basePath + '/yodlee/fastlink';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'bankId' is not null or undefined
        if (bankId === null || bankId === undefined) {
            throw new Error('Required parameter bankId was null or undefined when calling getFastlinkSessionUsingGET.');
        }

        if (bankId !== undefined) {
            localVarQueryParameters['bankId'] = ObjectSerializer.serialize(bankId, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FastlinkSession;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FastlinkSession");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get ProviderAccount
     * @param id id
     */
    public getProviderAccountUsingGET (id: number) : Promise<{ response: http.IncomingMessage; body: ProviderAccount;  }> {
        const localVarPath = this.basePath + '/yodlee/providerAccount/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProviderAccountUsingGET.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ProviderAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProviderAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Provider
     * @param id id
     */
    public getProviderUsingGET (id: number) : Promise<{ response: http.IncomingMessage; body: YodleeProvider;  }> {
        const localVarPath = this.basePath + '/yodlee/provider/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProviderUsingGET.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: YodleeProvider;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "YodleeProvider");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get UserSession
     * @param autoCreate autoCreate
     */
    public getUserSessionUsingGET (autoCreate?: boolean) : Promise<{ response: http.IncomingMessage; body: YodleeUserSession;  }> {
        const localVarPath = this.basePath + '/yodlee/userSession';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (autoCreate !== undefined) {
            localVarQueryParameters['autoCreate'] = ObjectSerializer.serialize(autoCreate, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.identityId.applyToRequest(localVarRequestOptions);

        this.authentications.identityRole.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: YodleeUserSession;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "YodleeUserSession");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
